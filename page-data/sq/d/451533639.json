{"data":{"allMdx":{"nodes":[{"fields":{"slug":"/posts/seo/robots.txt/","title":"robots.txt"},"frontmatter":{"draft":false},"rawBody":""},{"fields":{"slug":"/","title":"📝 r0k Wiki"},"frontmatter":{"draft":false},"rawBody":"---\ndate: 2021-12-21\nupdated: 2021-12-21\ntags:\n  - Readme\n---\n\n# 📝 r0k Wiki\n\n**필요할 때 꺼내쓰는 기억저장소**\n\n## Inspired by\n- [Vimwiki+Jekyll+Github.io로 나만의 위키를 만들자](https://johngrib.github.io/wiki/my-wiki/)\n- [theowenyoung/gatsby-theme-primer-wiki](https://github.com/theowenyoung/gatsby-theme-primer-wiki)\n- [Padosum Wiki](https://www.padosum.dev/)\n"},{"fields":{"slug":"/Web_API/Blob/","title":"Blob"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Blob\ndate: 2022-09-17\nupdated: 2022-09-17\ntags:\n  - Web API\n---\n\n[Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob)"},{"fields":{"slug":"/Web_API/DOMMatrixReadOnly/","title":"DOMMatrixReadOnly"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: DOMMatrixReadOnly\ndate: 2022-09-18\nupdated: 2022-09-18\ntags:\n  - Web API\n---\n\n[MDN 링크](https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrixReadOnly)\n\n> DOMMatrixReadOnly 인터페이스는 2D 및 3D 작업에 적합한 읽기 전용 4×4 행렬을 나타낸다.\n\n\n## Properties\n\n### `is2D`  (Boolean)\nmatrix가 2D matrix로 생성되었으면 `true`를 반환한다. 3D일 경우 false를 반환한다.\n\n\n### `isIdentity` \n- matrix가 [단위 행렬](https://en.wikipedia.org/wiki/Identity_matrix)인 경우 `true`를 반환한다.\n\n\n### `m11`, `m12`, `m13`, `m14`, `m21`, `m22`, `m23`, `m24`, `m31`, `m32`, `m33`, `m34`, `m41`, `m42`, `m43`, `m44`\n- [배정 밀도 부동 소수점 형식](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)으로된 값이며 [4x4 매트릭스](https://www.w3.org/TR/geometry-1/#DOMMatrix)를 나타낸다.\n- 이해하진 못햇지만 2d인 디스플레이 화면에서 3d를 나타내기 위해 벡터공간에서 4x4 행렬을 쓰는것같다.\n\t- https://www.youtube.com/watch?v=rHLEWRxRGiM&ab_channel=3Blue1Brown\n\t- https://stackoverflow.com/questions/32565827/whats-the-purpose-of-magic-4-of-last-row-in-matrix-4x4-for-3d-graphics\n\t- https://stackoverflow.com/questions/29079685/how-does-4x4-matrix-work-in-3d-graphic\n\n\n\n### 찾아보게된 경위\n- 수직으로 한칸 씩 이동하는 슬라이드를 구현하면서 `transform: translate3d()` 를 사용하게 되었고, 이때 `style` 어트리뷰트 문자열을 파싱하여 y값을 구하는 방법대신 Web API를 찾아보게됨.\n\n\n### translate 값 조회하기\n```javascript\nfunction getTranslateXY(element) {\n    const style = window.getComputedStyle(element)\n    const matrix = new DOMMatrixReadOnly(style.transform)\n    return {\n        translateX: matrix.m41,\n        translateY: matrix.m42\n    }\n}\n```\n"},{"fields":{"slug":"/Web_API/특정 텍스트를 찾은채로 페이지 이동하기 with 텍스트 프래그먼트/","title":"특정 텍스트를 찾은채로 페이지 이동하기 with 텍스트 프래그먼트"},"frontmatter":{"draft":false},"rawBody":"---\ncreated: 2024-05-12T17:56:49+09:00\nupdated: 2024-05-24T14:27:21+09:00\n---\n\n가끔 구글에서 특정 키워드로 검색을 하고 난 후 검색 결과 페이지로 이동하면 그 키워드가 형광펜으로 칠해진 채로 이동하는 걸 볼 수 있다. 이는 DOM (Document Object Model)의 동작이라기 보다는 BOM (Browser Object Model)의 동작이다.\n\n바로 [텍스트 프래그먼트](https://web.dev/articles/text-fragments?hl=ko)가 이를 가능하게 한다. URL 해시에 특정 구분자를 넣어 강조하고 싶은 문자열을 지정하면 문서에서 문자열과 매칭되는 곳에 강조표시를 해준다.\n\n[`https://blog.chromium.org/2019/12/chrome-80-content-indexing-es-modules.html==#:~:text=ECMAScript%20Modules%20in%20Web%20Workers==`](https://blog.chromium.org/2019/12/chrome-80-content-indexing-es-modules.html#:~:text=ECMAScript%20Modules%20in%20Web%20Workers)\n![[Pasted image 20240512175949.png]]\n이런식으로 말이다.\n\n크롬에서 우클릭하여\n\n\n일치시킬 문자열은 다양한 방법으로 지정할 수 있다.\n- [시작점과 종료점 설정](https://web.dev/articles/text-fragments?hl=ko)\n- [`prefix-` , `-suffix` 일치 조건 설정](https://web.dev/articles/text-fragments?hl=ko#prefix-_and_-suffix)\u001f\n- [한 번에 여러 개의 문자열 일치시키기](https://web.dev/articles/text-fragments?hl=ko#multiple_text_fragments_in_one_url)\n\n### 스타일 지정\n강조 표시는 노란색 배경색으로 입혀지는데, 이는 `::target-text` 선택자를 활용하여 커스텀할 수 있다\n```css\n:root::target-text {  color: black;  background-color: red;}\n```\n\n### 지원\n아쉽게도 엣지와 크롬에서만 기본적으로 지원하고 사파리의 경우 [특정 플래그를 켜야지만](https://www.reddit.com/r/MacOS/comments/14l1gcu/how_to_disable_safari_automatically_highlighting/) 사용가능하다.\n\n"},{"fields":{"slug":"/posts/my-setting/","title":"내 개발 환경 세팅 기록"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 내 개발 환경 세팅 기록\ndate: 2022-05-31\nupdated: 2022-12-18T15:40:45+09:00\ntags:\n  - my-setting\ncreated: 2022-12-18T15:40:45+09:00\n---\n\n> 내 개발환경 세팅에 대해 기록한다.\n\n## alfred\n- 현재 active 화면에서 보기\n  - ![image](https://user-images.githubusercontent.com/35283339/183840211-1b1227ab-affe-4262-ab2e-0c187333ea59.png)\n- 크롬 북마크를 alfred에서 검색하기\n  - ![image](https://user-images.githubusercontent.com/35283339/183840943-e945c650-b7aa-4419-8100-5e6fe9fe1e35.png)\n\n## history\nM1 맥북으로 개발환경을 다시 구성하면서 터미널 history 도 옮기고 싶어서 방법을 생각해봤다.\n\n[How can I transfer my bash history to a new system?](https://askubuntu.com/questions/652305/how-can-i-transfer-my-bash-history-to-a-new-system)\n\nzsh의 history는 .zsh_history 에 문자열형태로 존재한다.\n\ncroc 을 사용하여 해당 파일을 터미널로 이동시켰다.\n\n```\nbrew install croc\n// 보내는 곳\ncroc send [file(s)-or-folder]\n\n// 특정 코드를 보여준다.\n\n// 받는 곳\ncroc [특정코드 입력]\n```\n"},{"fields":{"slug":"/posts/javascript/asynchronous/","title":"callback부터 async await까지 - Javascript 비동기"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: callback부터 async await까지 - Javascript 비동기\ndate: 2021-08-24\ntags:\n  - javascript\n---\n\n# 동기와 비동기\n일반적으로 프로그램의 코드는 순차적으로 진행된다. 두번째 실행되는 코드는 첫번쨰 실행되는 코드가 완료될 때 까지 기다린 후 실행된다. 성능이 좋지 않은 컴퓨터로 특정 사이트에 접속했을 때, 화면이 보이기 전에 커서가 기다림을 나태나는 커서로 변하는걸 본적이 있을것이다. 이는 화면을 그리는 코드보다 먼저 실행되는 코드가 처리되는데 오래걸려서 생기는 현상이다. 이런 현상을 **blocking**이라 부르며, 이는 사용자의 경험을 망치는 요인중 하나이다. 여러 작업을 해야할 때 사용자를 기다리게하지 않기 위해 비동기 프로그래밍이 필요하다. **결국 사람이 편하자고 나온 것들이다 전부**\n\n## 실생활에서의 예시\n해결해야하는 A테스크와 B테스크가 있다고 가정하자.\n\n### 동기적으로 일을 하는 경우\n- 절차\n  1. A테스크를 할일 목록에 넣는다.\n  2. A테스크를 처리한다.\n  3. B테스크를 할일 목록에 넣는다.\n  4. B테스크를 처리한다.\n- 실생활 예시\n  - 줄을 서서 버스표예매를 하는 경우를 생각해보자. 가장 앞에 있는 사람만 표예매를 진행할 수 있고 뒤에있는 사람들은 그냥 기다리는 방법밖에없다.\n\n### 비동기적으로 일을 하는 경우\n- 절차\n  1. A테스크를 할일 목록에 넣는다.\n  2. B테스크를 할일 목록에 넣는다.\n  3. A테스크를 처리한다.\n  4. B테스크를 처리한다.\n- 실생활 예시\n  - 줄을 서있는 카페에 가서 커피를 시키는 경우를 생각해보자. 가장 앞에 있는 사람은 어떤것을 주문할지 말한 후, 진동벨을 받아 자리에 앉아 기다린다. 일하는 사람은 일단 주문부터 다 받고, 커피를 만들기 시작한다.\n\n## Javascript가 비동기를 다루는 법\n자바스크립트는 단일 스레드 위에서 작동한다. 함수가 호출되면 javascript 엔진은 함수를 평가하는 과정에서 해당 함수의 실행 컨텍스트를 생성한다. 그리고 그 컨텍스트는 콜 스택에 푸시된다. 콜 **스택**에 쌓인 실행 컨텍스트는 하나씩 POP되어 실행된다.\n\n`setTimeout`, `setInterval`, HTTP 요청, 이벤트 핸들러같은 비동기적인 함수들은 어떻게 처리될까?\n\n### 이벤트 루프와 이벤트 큐\n![https://poiemaweb.com/js-event](https://poiemaweb.com/img/event-loop.png)\n이벤트 루프, 큐는 유튜브 영상을 보는 동시에 댓글도 작성할 수 있는 것처럼 여러작업을 동시에 하는 것을 지원해준다.\n- 이벤트 루프\n  - 콜 스택과 이벤트 큐를 계속 감시하고 있다가, 콜 스택이 비어 있으며 테스크 큐에 대기중인 비동기 함수가 있을 경우 대기중인 함수를 콜 스택에 이동시켜 실행시킴\n- 이벤트 큐 (*콜백 큐, 테스크 큐 라고 불리기도함*)\n  - 비동기 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역\n- 마이크로 테스크 큐\n  - Promise의 후속처리 메서드의 콜백 함수가 보관되는 영역\n\n## 비동기 다뤄보기\n### 1. callback패턴\n```javascript\nconst request = (url, callback) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.onload = () => {\n        callback(xhr.response)\n    }\n    xhr.send();\n}\nrequest('https://jsonplaceholder.typicode.com/todos/1', console.log)\n```\n콜백 패턴은 가장 기본적인 패턴이다.\n\n내장 API인 `XMLHttpRequest`는 `onload()`라는 이벤트 핸들러를 지원한다. 이는 요청이 에러없이 완료되었을 때 실행된다. 해당 함수는 요청에 성공하면 실행시킬 콜백 함수를 매개변수로서 전달하였다. 그런데 만약 A요청으로 얻어온 정보를 가지고 B요청에 사용하려 하면 어떻게 해야될까?\n```javascript\nrequest('https://jsonplaceholder.typicode.com/todos/1', (response) => {\n  const userId = response.user.id; // 예시입니다.\n  request(`https://jsonplaceholder.typicode.com/users/${userId}`, console.log)\n})\n```\n이처럼 연속되는 비동기처리를 하려고하면 콜백 함수의 중첩이 발생하고 이는 코드의 복잡성을 높아지게한다.\n```javascript\nconst request = (url, callback) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.onload = () => {\n        callback(xhr.response)\n    }\n    xhr.send();\n}\ntry {\n    request('https://jsonplaceholder.typicode.com/todos/1', () => {\n        throw new Error()\n    })\n} catch (e){\n    consooe.error(e)\n}\n// 에러가 캐치되지 않는다!\n```\n`try catch`문을 통해 에러가 캐치되지 않는 것도 큰 문제이다. 에러는 caller(함수를 호출한 컨테스트)방향으로 전파되는데, 에러가 발생했을 때는 전파되어야할 컨테스트가 사라지기 때문이다.\n1. 비동기 함수인 `onload`가 호출되면 실행 컨텍스트가 만들어지고 콜 스택에 PUSH된다.\n2. 비동기 함수이므로 콜백 함수가 호출되는 것을 기다리지 않고 바로 스택에서 제거된다.\n3. 이후 응답을 받은 후 이벤트 큐에서 콜백 함수가 이벤트 큐로 이동되고 콜 스택이 비어질때 까지 기다리다가 이벤트 루프에 의해 콜 스택으로 PUSH되어 실행된다.\n\n`2`에서 `onload`가 실행 컨텍스트가 제거되었기 때문에 콜백 함수의 caller는 `request`함수가 아니게되어 의도했던거처럼 전파가 되지않아 에러처리가 되지 않는다.\n\n### 2. Promise\n위 문제를 해결하기 위해 Promise 빌트인 객체가 도입되었다. Promise는 비동기 함수 성공와 실패를 처리할 콜백 함수를 받는다. 리턴값은 Promise객체이다. ([브라우저별 지원형황](https://caniuse.com/?search=Promise))\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  ...\n  if (비동기 성공여부) {\n    resolve('성공');\n  } else {\n    reject('실패');\n  }\n})\nconsole.log(promise) // Promise {<pending>}\n```\nPromise 객체는 3가지 상태를 가진다.\n- `pending`\n  - 비동기 처리 대기중 (기본상태)\n- `fulfilled`\n  - 비동기 처리 성공 (콜백 함수 내부 `resolve()`로 인해 변경됨)\n- `rejected`\n  - 비동기 처리 실패 (콜백 함수 내부 `reject()`로 인해 변경됨)\n\n```javascript\nconst request = (url) => {\n    return new Promise((res, rej) => {\n        const xhr = new XMLHttpRequest();\n        xhr.open('GET', url);\n        xhr.onload = () => {\n            if (xhr.status === 200) {\n                res(JSON.parse(xhr.response))\n            } else {\n                rej(xhr.status)\n            }\n        }\n        xhr.send();\n    })\n\n}\nrequest('https://jsonplaceholder.typicode.com/todos/1')\n  .then(res => console.log(res)) // 성공시\n  .catch(err => console.error(err)) // 실패시\n```\n- `Promise.prototype.then`\n  - Promise가 `fulfilled`상태가 되면 호출되는 메서드\n- `Promise.prototype.catch`\n  - Promise가 `rejected`상태가 되면 호출되는 메서드\n\n```javascript\nrequest('https://jsonplaceholder.typicode.com/todos/1')\n  .then(res => request(`https://jsonplaceholder.typicode.com/users/${res.userId}`))\n  .then(res => console.log(res))\n  .catch(err => console.error(err))\n```\n`then`메서드 체이닝을 통해 연속적인 비동기 작업처리했다. 아까 콜백 패턴보다 더 보기 편하다.\n\n### 3. 제너레이터\nES6에 도입된 제너레이터는 함수 내부 코드 블록을 실행했다가, 일시중지했다가 다시 실행시킬수 있는 특수한 함수다. 즉 기존 함수들은 들어가고 나가는게 1번씩만 가능하다. 제너레이터는 여러번 할 수 있다. ([브라우저별 지원현황](https://caniuse.com/?search=generator))\n\n제너레이터 함수 선언시 `function`키워드 뒤에 `*`붙여 선언한다.\n```javascript\nfunction* genFunc() {\n  yield 1;\n  yield 2;\n}\nconst generator = genFunc();\nconsole.log(generator.next()); // {value: 1, done: false}\nconsole.log(generator.next()); // {value: 2, done: false}\nconsole.log(generator.next()); // {value: undefined, done: true}\n```\n제너레이터 함수는 제너레이터 객체를 반환한다. 반환된 객체는 [`Symbol.iterator`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator)를 상속받는 [이터러블](https://ko.javascript.info/iterable)이면서 `next()`메서드를 가지고 있는 이터레이터이다.\n\n1. 제너레이터 함수의 실행으로 제너레이터 객체가 만들어진다.\n2. `next()`의 호출로 `yield`표현식까지의 코드블록을 실행하고 `yield`된 값을 가진 `{ value: 값, done: boolean }`객체를 반환한다.\n3. 여러번 실행하여 모든 `yield`가 반환되면 `{ value: undefined, done: true }`형태로 반환된다.\n\n```javascript\nfunction* idMaker(){\n  var index = 0;\n  while(index < 3)\n    yield index++;\n}\n\nvar gen = idMaker();\n\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\nconsole.log(gen.next().value); // undefined\n```\n`yield`키워드는 코드를 일시정지 시킨 후 함수 호출자에게 제어권을 양도하게 된다. 그래서 `while`문 내부에서도 코드를 멈췄다가 재개하는게 가능하다.\n\n```javascript\nconst asyncFunc = (generatorFunc) => {\n  const generator = generatorFunc();\n  const onResolved = (arg) => {\n    const result = generator.next(arg);\n    console.log(result)\n    return result.done\n      ? result.value\n      : result.value.then(res => onResolved(res));\n  }\n}\n\n(asyncFunc(function* fetchTodo() {\n  const url = 'https://jsonplaceholder.typicode.com/todos/1';\n  const response = yield fetch(url);\n  const json = yield response.json();\n  console.log(json)\n})())\n// {value: Promise, done: false} <- fetch()\n// Promise {<pending>} <- fetch()의 결과\n// {value: Promise, done: false} <- json()\n// {userId: 1, id: 1, title: \"delectus aut autem\", completed: false} <- json()의 결과\n// {value: undefined, done: true}\n```\n`asyncFunc()`함수 내부에서 재귀적으로 `onResolved()`를 실행하여 매개변수로 받은 제네레이터 함수내부의 `yield`를 처리하고, `Promise`객체의 `then`메소드를 실행시킨다.\n\n### 4. async await\nES8에서 도입된 async/await는 더 가독성 좋은 비동기 처리를 도와준다. 이는 Promise를 기반으로 동작하며 `then`, `catch`같은 후속 메서드 사용없이 동기처럼 프로미스를 사용할 수 있다. ([브라우저별 지원현황](https://caniuse.com/?search=async%20await))\n\n\n\n`async`키워드를 사용한 함수는 언제나 Promise객체를 반환한다.\n```javascript\nasync function a() {\n    return 1\n}\nconsole.log(a());\n// Promise {<fulfilled>: 1}\n```\n\n`await`키워드는 Promise객체가 처리가 완료될 때까지 기다리다가 결과를 반환한다.\n```javascript\nasync function fetchTodo() {\n  const url = 'https://jsonplaceholder.typicode.com/todos/1';\n  const response = await fetch(url);\n  const json = await response.json();\n  console.log(json)\n}\nfetchTodo();\n```\n\n만약 `async`함수내부에 `await`키워드가 여러개라면 순차적으로 처리가 완료될 때까지 가디린 후 반환한다. 내부에 여러개의 `await`함수가 필요한 경우 `Promise.all()`메서드를 사용하는 것이 좋다.\n```javascript\nasync function foo() {\n  // good\n  const res = await Promise.all([\n    new Promise(resolve => setTimeout(() => resolve(1), 3000))\n    new Promise(resolve => setTimeout(() => resolve(2), 2000))\n    new Promise(resolve => setTimeout(() => resolve(3), 1000))\n  ]); // [1,2,3]\n\n\n  // bad\n  const a = await new Promise(resolve => setTimeout(() => resolve(1), 3000))\n  const b = await new Promise(resolve => setTimeout(() => resolve(2), 2000))\n  const c = await new Promise(resolve => setTimeout(() => resolve(3), 1000))\n  const result = [a,b,c] // [1,2,3]\n}\n```\n\n## 참고\n- [일반적인 비동기 프로그래밍 개념](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Concepts)\n- [iterable 객체](https://ko.javascript.info/iterable)\n- [모던 자바스크립트 Deep dive](http://www.yes24.com/Product/Goods/92742567)\n"},{"fields":{"slug":"/posts/error/모노레포에서 서로 다른 react 버전 사용시 에러/","title":"모노레포에서 서로 다른 React 버전 사용시 에러"},"frontmatter":{"draft":false},"rawBody":"---\ncreated: 2024-05-05T17:03:35+09:00\nupdated: 2024-05-05T17:20:45+09:00\ntags:\n  - 디깅\n---\n\n## 환경\n\n모노레포에서 패키지마다 vite + react (A), Next.js (B) 각각 다르게 사용중\nNext.js 13을 쓰려다보니 vite + react 패키지에서 쓰는 17버전과 다르게 18버전을 사용해야함\n\nB 패키지에 Swiper 설치 후 컴포넌트를 렌더링하면 아래와 같은 에러 메시지 발생\n```text\nError: Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\n    at resolveDispatcher (/node_modules/.pnpm/react@17.0.2/node_modules/react/cjs/react.development.js:1476:13)\n    at useState (/node_modules/.pnpm/react@17.0.2/node_modules/react/cjs/react.development.js:1507:20)\n    at /node_modules/.pnpm/swiper@10.3.1/node_modules/swiper/swiper-react.mjs:140:51\n```\n\nB의 package.json에 resolution을 명시해줘도 17버전을 참조함.\n에러 디깅을 하다가 문득 next.js `transpilePackages` [옵션](https://nextjs.org/docs/app/api-reference/next-config-js/transpilePackages)이 떠오름.\n\n이는 next.js에서 lodash-es를 쓰려고 하다가 commonjs 문제를 해결하기 위해 썼던 *특정 패키지를 트랜스 파일링해주는 옵션*임.\n\nSwiper에서 자꾸 다른 패키지에서 사용되는 react 버전을 참조 문제가 해당 옵션을 통해 미리 B 패키지 레벨에서 트렌스 파일링하면 해당 패키지 리액트를 바라보게 되어 해결될거 라고 생각하였고 테스트 해보니 맞았음.\n\n\n\n"},{"fields":{"slug":"/posts/javascript/자바스크립트 데드 코드 제거/","title":"자바스크립트 데드 코드 제거"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 자바스크립트 데드 코드 제거\ndate: 2023-10-14\ntags:\n  - javascript\n  - 개선\ncreated: 2023-10-14T17:49:20+09:00\nupdated: 2024-03-17T15:03:17+09:00\n---\n## 왜 데드코드를 관리해야 하는가?\n\n- 유지보수시 방해가 된다.\n\t- 불필요하게 export하는 변수가 많으면 IDE에서 자동 import할 때 속도도 느려지고, 비슷한 심볼들이 많아지면 개발자로 하여금 헷갈리게 하는 방해요소가 된다.\n\t- 신규 동료가 합류하게 되는 경우 인지해야할 요소들이 불필요하게 늘어난다.\n- 소나큐브같은 정적 코드 분석 툴을 사용할 때 정말 개선이 필요한 부분이 아닌데 검사의 대상이 된다.\n\n\n### 데드코드 정리 도구 활용\n\n\n#### [**ts-prune**](https://github.com/nadeesha/ts-prune)\n- 사용되지 않고 있는 export된 변수를 찾아준다.\n- 2023-10-14 기준 maintanence mode가 되었기 때문에 비추\n```\nts-prune -p tsconfig.json // tsconfig 설정파일 전달\n```\n\n##### 사용후기\n\n- 사용되고 있는 변수도 결과에 나오는 경우가 있다.\n- export 됐지만, 파일 외부에서는 사용하지 않고 내부에서 사용하는 경우도 결과에 나온다. (해당 정보를 필터링하는 옵션이 최근 추가됐다.)\n- index.ts에서 한번에 묶어서 export하는 경우 잡히지 않음\n```ts\nexport { default as PositionDraftRequestDto } from './PositionDraftRequestDto';\nexport { default as PositionFindResponseDto } from './PositionFindResponseDto';\n```\n\n\n#### [**ts-remove-unused**](https://github.com/line/ts-remove-unused)\n\n- 명령어를 실행하면 사용되지 않는 코드를 찾아 제거해 준다.\n- line에서 공개한 오픈소스이다\n\n#### 사용후기\n- `--skip` 옵션으로 ignore할 파일을 지정할 수 있으나 하나하나 찾아 설정해줘야하는 점이 불편했다.\n    - 예) 리액트 최상위 파일 App.tsx 라거나 schema.tsx 등..\n- 실제로 사용하는 부분이 있음에도 지워지는 경우가 있었다.\n        \n\n#### [**knip**](https://github.com/webpro/knip)\n- ts-prune 메인테이너가 추천하는 도구이다. \n- 사용되지 않는 파일, 변수, 타입, 의존성 등을 찾아주고 export된 것중에 이름이 겹치는 것도 알려줌\n- 설정파일에 애플리케이션의 엔트리 파일들, 검사에 포함할 파일들에 대한 필터링을 할 수 있다.\n```ts\nimport type { KnipConfig } from 'knip';\n\nconst config: KnipConfig = {\n  entry: ['src/index.ts'], // 애플리케이션이 시작될 때 엔트리 포인트가 되는 부분 설정가능\n  project: ['src/**/*.ts'],\n};\n\nexport default config;\n```\n- 프레임워크별로 [기본 설정 세팅을 제공](https://github.com/webpro/knip#plugins)해주고 있다.\n\n\n#### 이외 도구들\n- [https://www.npmjs.com/package/find-unused-exports](https://www.npmjs.com/package/find-unused-exports)\n- [https://www.npmjs.com/package/unimported](https://www.npmjs.com/package/unimported)\n- [https://github.com/sweepline/eslint-plugin-unused-imports](https://github.com/sweepline/eslint-plugin-unused-imports)\n\n## 예방하기\n개발하는 중간중간 정적분석 도구를 사용해 데드코드가 생기는걸 미리 방지하는것이 제일 좋다고 생각한다.  eslint를 활용해 사용되지 않는 코드가 존재하는 경우 warning이나 error가 발생하도록 하자.\n- [https://eslint.org/docs/rules/no-constant-condition](https://eslint.org/docs/rules/no-constant-condition)\n- [https://eslint.org/docs/rules/no-unused-vars](https://eslint.org/docs/rules/no-unused-vars)\n- [https://eslint.org/docs/rules/no-unreachable](https://eslint.org/docs/rules/no-unreachable) \n\n"},{"fields":{"slug":"/posts/javascript/webpack/","title":"웹팩을 쓰는 이유와 사용법 정리"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 웹팩을 쓰는 이유와 사용법 정리\ndate: 2021-01-18\ntags:\n  - javascript\nkeywords:\ncreated: 2024-03-17T15:02:23+09:00\nupdated: 2024-03-17T15:02:23+09:00\n---\n\n# 웹팩이란?\n프론트엔드 개발시 여러 파일을 하나 혹은 N개의 결과물로 만들기 위한 모듈 번들러. 비슷한 도구로는 parcel, snowpack 등이 있다.\n- 웹팩에서의 모듈\n\t- 하나의 역할을 수행할 수 있는 단위\n\t- 프로젝트를 구성하는 모든 자원 (html, css, js, font, image)\n\n### 모듈을 번들링한다는게 무슨 말이지?\n- `.js`, `.sass`, `.jpg` 등 프로젝트에 사용된 다수의 파일들을 빌드하면서 압축, 전처리, 최적화 등을 해주고 1개 혹은 n개의 파일로 묶어주는것\n\t- 웹팩 라이브러리를 사용하면 가능한것들의 예시\n\t\t- 개발시에 사용한 이미지를 webpack을 통해서 빌드하면 더 작은 용량으로 압축\n\t\t- `.scss`, `.sass`, `.less` 등으로 만들어진 preprocessors들을 브라우저에서 사용가능한 `.css` 파일로 변환\n\t\t- 여러개의 `.js`파일을 결과물을 1개의 `.js` 파일로 빌드\n- 과거에는 `.html`파일 내부에 script태그로 라이브러리들을 불러오도록 작성했다. script태그로 비동기적으로 파일을 불러오게되면 네트워크의 상태나 script태그의 위치에 따라 개발자가 의도하지않았던 결과를 초래할 수 있고, 코드관리에도 불편한 점이 있었다. 웹팩은 이러한 점들 또한 해결해준다.\n\n### 웹팩으로 번들링하는 이유는?\n1. 초기 웹은 간단한 구조일거라고 생각하고 js를 개발함 -> 웹이 발전해가면서 js가 복잡해짐 -> 여러 문제점 발생\n\t- 변수 스코프 겹침\n\t- 브라우저별 HTTP 요청 숫자 제약\n\t\t> 최신 브라우저들은 대부분 한번에 6개의 요청을 보낼 수 있다. ie11은 13개\n\t- 미사용 코드 관리 등\n2. 초기에는 grunt, gulp같은 웹 테스크 매니저툴이 웹팩과 비슷한 역할을 함\n3. 웹 테스크 매니저의 한계를 개선하고, 추가적인 기능이 가능해진 웹팩이 만들어지게 됨\n\t- 간단한 설정\n\t- lazy-loading\n\t- task를 위한 라이브러리 관리\n\n### 명령어\n- `webpack`\n\t- 프로젝트 빌드를 수행함.\n\t- 보통 cli창에서 webpack 명령을 일일이 수행하지 않고 package.json 의 `scripts`옵션에 미리 등록하여 사용함\n\t- 옵션을 줘보자\n\t\t- `--mode=none|development|production`\n\t\t\t- 현재 빌드하려는 모드를 설정한다.\n\t\t\t- 이 값을 사용해 상황마다 특정 웹팩 라이브러리만 빌드에 사용되게 할수 있다.\n\t\t\t\t- ex) 개발시에는 난독화 라이브러리를 적용시키지 않도록하여 에러가 발생했을 때 좀 더 디버깅하기 쉬운 환경을 만들수 있다.\n\t\t- `--entry=src/index.js`\n\t\t- `--output=public/output.js`\n\t\t```json\n\t\t...\n\t\t\"scripts\": {\n\t\t\t\"build\": \"webpack --mode=development --entry=src/index.js --output=dist/main.js\"\n\t\t},\n\t\t...\n\t\t```\n\t- 이처럼 옵션값들을 package.json에서 수정하는 것들은 가독성, 유지보수 측면에서 매우 비효율적임.\n\t\t아래 처럼 js파일로 만들어 관리하는 것이 훨씬 가독성이 좋으며 권장되는 방법\n\t\t```js\n\t\t// webpack.config.js\n\t\t// `webpack` command will pick up this config setup by default\n\t\tvar path = require('path');\n\n\t\tmodule.exports = {\n\t\t\tmode: 'none',\n\t\t\tentry: './src/index.js',\n\t\t\toutput: {\n\t\t\t\tfilename: 'main.js',\n\t\t\t\tpath: path.resolve(__dirname, 'dist')\n\t\t\t}\n\t\t};\n\t\t```\n\n### build 결과물\n- webpack은 사용된 js파일을 배열로 관리한다.\n- 결과물 내부는 즉시실행함수(IIFE)를 활용하여 작성된다.\n\n#### build 결과물 - sourcemap\n- 웹팩의 결과물은 난독화가 가능하다. 그러나 개발하면서 디버깅을 하기위해서는 가독성이 좋은 코드를 브라우저에서 볼수 있어야한다.\n- 웹팩은 해당 부분을 설정할 수 있는 옵션을 제공한다\n\t```js\n\t...\n\t\tdevtool: 'source-map'\n\n\t};\n\t...\n\t```\n\n\n### 과거의 툴 gulp, grunt\n- 파일에 대해 개발자가 직접 설정을 해주고, 각 파일에대해 태스크를 진행하는 방식\n\t- project\n\t\t- js - js - js - js\n\t\t- css - css - css - css\n\t\t- jpg - jpg - jpg - jpg\n\t- 트리쉐이킹, 모듈 번들링이 불가능했음\n\n- 웹팩은?\n\t- project\n\t\t- js - js - jpg - css\n\t\t\t- css\n\t\t\t\t- woff2\n\t\t\t\t- woff\n\t\t\t\t- svg\n\t\t\t\t- css\n\t- 진입점이 주어지면 나머지의 연관관계를 웹팩이 해석해서 결과물을 만들어냄\n\t- 트리쉐이킹, 모듈 번들링이 가능\n\n# webpack의 주요 속성들\n- entry\n- output\n- module\n- mode\n\n### entry\n```js\n// webpack.config.js\nmodule.exports = {\n  entry: './src/index.js'\n}\n```\n- 웹팩이 프로젝트를 빌드할 때, 첫 진입점이 된다. (js파일 경로를 기입한다.)\n\t- entry를 분리하는 경우는 MPA에 적합함\n- A라는 파일에서 B라는 파일을 import하게되면 A는 B파일에 의존하게된다 -> 의존성관계 생김 == 디펜던시\n\t- 웹팩은 디펜던시 그래프를 통해 어떤 파일들이 사용되는지 판단하고 빌드를 진행함\n\n\n### output\n```js\n// webpack.config.js\nmodule.exports = {\n\toutput: {\n\t\tfilename: 'bundle.js',\n\t\tfilename: '[name].bundle.js', // 결과 파일명에 entry 속성을 포함\n\t\tfilename: '[id].bundle.js', // 결과 파일 이름에 웹팩 내부적으로 사용하는 모듈 ID를 포함하는 옵션\n\n    filename: '[name].[hash].bundle.js',\n    // 매 빌드시 마다 고유 해시 값을 붙이는 옵션\n    /**\n     * A.a13.js\n     * B.a13.js\n     * ------\n     * A 파일만 변경 후 빌드\n     * ------\n     * A.b2d.js\n     * B.b2d.js\n     *\n     */\n\n\n\n    filename: '[contenthash].bundle.js',\n    // 각 파일마다 가지고 있는 콘텐츠에 의해 계산되는 hash값을 가짐\n    /**\n     * A.bs1.js\n     * B.as2.js\n     * ------\n     * A 파일만 변경 후 빌드\n     * ------\n     * A.2oq.js\n     * B.as2.js\n     *\n     */\n\n    filename: '[chunkhash].bundle.js',\n    // 웹팩의 각 모듈 내용을 기준으로 생생된 해시 값을 붙이는 옵션 (webpack entry를 기반으로 정의되어 고유의 hash 값을 가짐)\n    // 각 파일마다 가지고 있는 콘텐츠에 의해 계산되는 hash값을 가짐\n    /**\n     * A.a13.js\n     * B.a13.js\n     * ------\n     * A 파일만 변경 후 빌드\n     * ------\n     * A.baq.js\n     * B.a13.js\n     *\n     */\n\n  }\n}\n```\n- 빌드가 완료된 후 결과물 파일의 경로와 파일명을 지정해준다.\n- `hash`, `chunckhash` 옵션을 파일명에 추가한 경우, 배포시에 생기는 캐시문제를 해결해 줄수 있다. (빌드할 때 마다 다른 해쉬가 붙기때문에 `index.html`만 invalidation되면 새로운 js파일을 불러오기 때문이다)\n\t- `hash`\n\t\t- 빌드를 할 때마다, 매번 새로운 값들을 파일명 뒤에 붙게되고 이로 인해 변경사항이 없는 파일도 유저는 다시 로드하게되어 비효율적이다.\n\t- `chunkhash`\n\t\t- webpack entry를 기반으로 정의되어 고유의 hash 값을 가짐 (변경된 파일만  변경되어 `hash`보다는 효율적)\n  - 참고\n  \t- [hash vs chunkhash vs contenthash](https://sk92.tistory.com/4)\n\t\t- [What is the purpose of webpack [hash] and [chunkhash]?](https://stackoverflow.com/questions/35176489/what-is-the-purpose-of-webpack-hash-and-chunkhash)\n\n\n### loader\n```js\n// webpack.config.js\nmodule.exports = {\n  module: { // 엔트리나 아웃풋 속성과는 다르게 module라는 이름을 사용\n    rules: []\n  }\n}\n```\n- js가 아닌 웹자원들을 변환하기 위해사용\n\t- sass -> css, svg -> svgr 등 다양함\n\n```js\nmodule: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['css-loader']\n      }\n    ]\n\t}\n```\n- loader = 도구\n- test = 도구를 적용시킬 대상의 파일명을 정규표현식으로 필터링한다.\n- 예시\n\t- .ts 파일을 모두 .js로 트랜스파일한다.\n\t```js\n\t{ test: /\\.ts$/, use: 'ts-loader' },\n\t```\n\t- 프로젝트에 사용된 .css파일을 로드한다.\n\t```js\n\t{ test: /\\.css$/, use: 'css-loader' },\n\t```\n\n> https://webpack.js.org/loaders/ <br/>\n웹팩에서 사용가능한 로더들의 리스트. 각 로더에 대한 사용법과 github 저장소의 링크를 제공한다.\n\n\n#### loader 적용순서는 오른쪽->왼쪽\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.scss$/,\n      use: ['style-loader', 'css-loader', 'sass-loader']\n    }\n  ]\n}\n```\n1. 위에 코드는 `.scss`파일들을 찾아 sass-loader로 전처리하여 css로 변환하고\n2. css-loader로 `.css`파일들을 웹팩에서 인식하게 해준다.\n  - 난독화 되지않은 build 결과물을 보게되면, css코드로 보이는 문자열이 js내부에 존재하는걸 알수 있다.\n  - js가 애플리케이션이 작동할 때 동적으로 html 내부에 style태그로 삽입해주는 것이다. 이런 이유로 index.html을 보면 head내부는 스타일태그가 없이 깨끗하다.\n3. style-loader는 인식된 css를 js로 동적으로 로드할 수 있게끔 도와준다.\n\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.scss$/,\n      use: ['css-loader', 'sass-loader', 'style-loader']\n    }\n  ]\n}\n```\n위와 같이 설정하고 빌드를 시도하가 되면 아래 오류가 발생한다.\n```sh\nERROR in ./src/base.css\nModule build failed (from ./node_modules/mini-css-extract-plugin/dist/loader.js):\nModuleParseError: Module parse failed: Unexpected token (1:2)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> p {\n|       color: blue;\n| }\n```\n- 이처럼 순서가 사용되는 로더의 순서가 제대로 배치되지 않으면 웹팩에서는 오류가 발생한다.\n  - `.scss`, `.sass` 파일을 `.css`로 변환하기 위해서는 sass-loader가 선행되어야함. 그 이후 css-loader로 인식하게 한뒤 style-loader로 js내부에 css를 담도록 해야함\n\n- 내가 사용하려는 파일에 따라 로더의 종류, 로더를 입력하는 순서가 달라진다.\n\n### mode\n- 웹팩실행시 어떤 환경을 위해 빌드하는지에 대한 구분자\n- 웹팩에서 제공하는 기본값들은 `none`, `development`, `production`이 있다.\n\n### plugins\n- 웹팩의 동작에 추가적인 기능을 추가할 수 있는 기능\n> loader: 파일을 해석하고 변환함 <br /> plugins: 결과물의 형태를 바꿈\n- 플러그인 라이브러리의 instance를 배열형태로 받는다.\n\n```js\n// webpack.config.js\nvar webpack = require('webpack');\nvar HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  plugins: [\n    new HtmlWebpackPlugin(),\n    new webpack.ProgressPlugin()\n  ]\n}\n```\n\n\n## [웹팩 데브 서버](https://webpack.js.org/configuration/dev-server/)\n프론트엔드 개발시, 대부분의 개발이 react, angular, vue 등을 사용하여 진행된다. 각 도구들은 각자의 문법을 가지고 있고 react와 vue같은 경우는 파일확장자명도 다르다. (.jsx, .tsx, .vue) 이를 브라우저에서 실행시키기 위해서는 브라우저가 이해할 수 있는 html,css,js로 변경해야 한다. 하지만 개발할 때 코드 변경후 매번 저장하고 다시 빌드명령어를 치는건 비효율적이다. 웹팩 데브서버는 이런 부분을 해결해주고 추가적으로 로컬개발시 편의성을 제공해준다. (타입스크립트를 사용할 때 파일이 변경된걸 감지하고 매번 자동으로 트랜스파일을 해주는 tsc-watch와 비슷한 맥락)\n\n- 설치\n\t```shell\n\tnpm i webpack webpack-cli webpack-dev-server  -D\n\t```\n- package.json에 명령어 등록\n\t```json\n\t\"scripts\": {\n\t\t\t\"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n\t\t\t\"dev\": \"webpack serve\"\n\t\t},\n\t```\n- 실행\n\t```shell\n\tnpm run dev\n\t```\n\n### 특징\n- 데브서버로 빌드된 내용은 메모리상으로만 존재하고 파일시스템 상에는 존재하지 않는다. (메모리상에 적재하는 것이 파일시스템상에서 파일 입출력을 하는것 보다 빠르기 때문이다.)\n- 파일을 저장할 때 마다 새로 빌드해서 최신코드를 반영해줌\n\n## 웹팩 설정 파일 분석해보기\n```js\nvar path = require('path')\nvar webpack = require('webpack')\n\nmodule.exports = {\n  mode: 'production', // 해당 웹팩 설정파일은 배포를 위한 모드이다.\n  entry: './src/main.js', // 웹팩이 빌드를 시도할 때, 첫 진입점 파일을 의미한다.\n  output: {\n    path: path.resolve(__dirname, './dist'), // 빌드의 결과물이 저장될 폴더명\n    publicPath: '/dist/', // 1) 아래 작성\n    filename: 'build.js' // 빌드 결과물의 이름\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          'vue-style-loader',\n          'css-loader'\n        ],\n\t\t\t},\n\t\t\t// .css 확장자를 가진 파일 모두, css-loader, vue-style-loader를 적용시킨다.\n\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: {\n          loaders: {\n          }\n          // other vue-loader options go here\n        }\n\t\t\t},\n\t\t\t// .vue 확장자를 가진 파일 모두, vue-loader를 적용시킨다.\n\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        exclude: /node_modules/\n\t\t\t},\n\t\t\t// .js 확장자를 가진 파일 모두, babel-loader를 적용시킨다. 단, node_modules 폴더는 제외시킨다.\n\n      {\n        test: /\\.(png|jpg|gif|svg)$/,\n        loader: 'file-loader',\n        options: {\n          name: '[name].[ext]?[hash]'\n        }\n\t\t\t}\n\t\t\t// .png|jpg|gif|svg 확장자를 가진 파일 모두, file-loader를 적용시킨다. 이때 파일명 뒤에 해쉬를 붙인다. (이미지가 캐싱되어도 해쉬값이 변경되면 이미지 업데이트시 다시 새로운 이미지를 불러오게하기 위함)\n\n    ]\n\t},\n\n  resolve: {\n\t\t// 2\n    alias: {\n\t\t\t'vue$': 'vue/dist/vue.esm.js'\n    },\n\t\t// 3\n    extensions: ['*', '.js', '.vue', '.json']\n  },\n\n\t// 데브 서버 실행시, 옵션지정 참고 - https://webpack.js.org/configuration/dev-server/\n\tdevServer: {\n\t\thistoryApiFallback: true,\n\t\tnoInfo: true,\n\t\toverlay: true\n\t},\n\n\t// 빌드결과물 크기에 대한 경고를 띄울수있는 옵션 - https://webpack.js.org/configuration/performance/\n  performance: {\n    hints: false\n\t},\n\n\t// 소스매핑스타일에 대한 옵션 (빌드에 대한 소요시간에 영향을 끼칠 수도 있다) - https://webpack.js.org/configuration/devtool/\n  devtool: '#eval-source-map'\n}\n```\n\n### 모르는 부분 검색결과\n1. `output.publicPath`\n\t- `path`와는 다르게 빌드된 결과물이 배포되었을 때 해당 파일이 존재할 디렉토리를 의미한다.\n\t- `publicPath: \"/dist\"` 지정 여부에 따른 결과\n\t\t```html\n\t\t<script src=\"/bundle.js\"></script></body>\n\t\t<script src=\"/dist/bundle.js\"></script></body>\n\t\t```\n\t\t- https://example.com/bundle.js\n\t\t- https://example.com/dist/bundle.js\n\t- 이런것도 가능하다.\n\t\t- aws S3, cloudefront, route53를 사용한다고  가정함\n\t\t- `package.json` 내부에 version 변수를 js로 불러온 후 `publicPath`로 지정한다. 그 후 aws s3에 빌드파일을 S3에 업로드할 때 해당버킷에 폴더를 version 변수와 같은이름으로 생성한 후 업로드하면 버전별로 빌드파일을 분리해서 업로드할 수 있다.\n\t- 참고\n\t  - [Public Path](https://webpack.js.org/guides/public-path/)\n\t\t- [What does “publicPath” in Webpack do?](https://stackoverflow.com/questions/28846814/what-does-publicpath-in-webpack-do)\n2. `resolve.alias`\n\t- 프로젝트 내부에서 사용할 별칭에 대해 실제 엔티티를 매칭해준다.\n\t\t- `'vue$': 'vue/dist/vue.esm.js'`\n\t\t\t```js\n\t\t\timport Something from  './component/some' // some.js some.json 위에서 등록한 확장자는 생략가능 (여기서 * 설정값은 모든 파일 확장자를 뜻함)\n\t\t\t```\n3. `resolve.extensions`\n\t- 프로젝트 내부에서 사용할 모듈에 대해 import시 확장자를 붙이지 않아도 된다.\n\t\t- `['*', '.js', '.vue', '.json']`\n\n\n> 본 내용은 [프론트엔드 개발자를 위한 웹팩](https://www.inflearn.com/course/%ED%94%84%EB%9F%B0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%9B%B9%ED%8C%A9) 강의을 보고 정리한 내용입니다.\n"},{"fields":{"slug":"/posts/frontend/performance-tip/","title":"프론트엔드 성능 최적화 팁 기록"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 프론트엔드 성능 최적화 팁 기록\ndate: 2024-01-01\ntags:\n  - javascript\n  - 성능최적화\ncreated: 2023-10-14T17:49:20+09:00\nupdated: 2024-01-01T18:36:57+09:00\n---\n자세히는 적지 않고 기억을 위해 간단하게 작성한 문서입니다\n\n\n### Next.js에서 Swiper 내부에 Image 컴포넌트 사용시 2번 호출되는 버그 해결\n```diff\n<Image\n\tfill\n\tclassName=\"swiper-lazy\"\n-\tdata-src={url}\n\tloader={imageLoader}\n\tsizes=\"720px\"\n\tcss={companyRepresentativeImageStyle}\n\n```\nhttps://github.com/nolimits4web/swiper/issues/3017#issuecomment-477654257\n이미지가 네트워크 탭에서 항상 2번 호출되는걸 확인할 수 있었다. 위 이슈를 참고하니, 코드 상의 버그인듯하여 수정\n\n### Lazy 로딩 활용\n- 반응형 디자인이 아니라 적응형 디자인이면서 클라이언트에서 디바이스 크기에 따라 분기처리를 하고 있다면 Lazy 로딩을 활용해 필요한 코드만 불러오도록 하자\n\n### fetch 우선순위 설정하기\nhttps://web.dev/articles/fetch-priority?hl=ko\n- css-in-js를 사용하는 경우, css 내부에서 사용해야하는 이미지가 있는 경우, 브라우저는 자바스크립트가 모두 실행되고 나서야 해당 이미지가 필요한 것을 알 수 있다. 이를 메타태그를 활용해 미리 호출하도록 하자\n\n#### 참고하면 좋은 링크들\n- [Fetch Priority API로 리소스 로드 최적화](https://web.dev/articles/fetch-priority?hl=ko)\n- [조기에 네트워크 연결을 설정하여 체감되는 페이지 속도 개선](https://web.dev/articles/preconnect-and-dns-prefetch?hl=ko)\n- [Using dns-prefetch](https://developer.mozilla.org/en-US/docs/Web/Performance/dns-prefetch)\n\t- https://www.nray.dev/\n- https://ui.toast.com/weekly-pick/ko_2021117"},{"fields":{"slug":"/posts/library/biome/","title":"eslint에서 biome로"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: eslint에서 biome로\ndate: 2024-09-14\nupdated: 2024-09-14\ntags:\n  - 개선\n---\n\n## 도입한 이유\n\neslint가 무거워서 웹스톰이 가끔 매우 느려진다. 온갖 설정을 해줘도..\n\nlint-staged에서 eslint —fix를 쓰고 있는데 이것도 느리다..\n\n## 과정\n\n공식문서를 그대로 이행한다.\n@biomejs/biome를 설치하고 (~~단순 biome으로 설치하지말 것~~)\n기존에 있던 eslint룰을 마이그레이션 하기 위한 작업을 진행한다.\n\n그 후 `pnpm biome lint --write` 명령어를 통해 린트를 돌려본다.\neslint와는 어떻게 다른지 린트에러나 워닝들을 수정해보면 알아갈 수 있다.\n`--unsafe` 옵션을 붙이면 수정 가능한 부분은 알아서 수정해준다.\n\n기존 eslint 의존성을 제거하고, 웹스톰에서도 eslint는 비활성화 시킨 후 biome로 동작하도록 기존 플러그인 제거 후 biome플러그인을 설치한다. 그 후 웹스톰을 리로드하면… 겁나 빨라진다.\n기존 lint-stage 에서 eslint fix 를 실행시키던 것도 biome로 변경해주자\n\n실제로 운영해보면서 장단점을 하나씩 정리해 나가자\n\n### 비고\n\n[Biome - 차세대 JS Linter와 Formatter](https://klloo.github.io/biome/)\n\n- 러스트로 제작되었음\n- 프리티어팀에서 개최한 대회에서 우승할 정도로 빠르고 프리티어 기능을 많이 지원함\n- 린트와 포매터 역할을 동시에 해준다.\n- 아직 지원하지 않는 언어들이 꽤 존재함.\n"},{"fields":{"slug":"/posts/monitoring/sentry/","title":"Sentry"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Sentry\ndate: 2022-11-07\nupdated: 2023-05-01T15:55:37+09:00\ntags:\n  - Sentry\ncreated: 2022-11-17T22:39:34+09:00\n---\n\n## crash free sessions 활성화\n- crash free sessions는 특정 시간동안 앱이 깨지지 않고 작동한 시간 퍼센티지를 나타낸다.. 즉, 높을수록 안정적인 것\n- 해당 퍼센티를 기준으로 [알림을 설정](https://docs.sentry.io/product/alerts/alert-types/#sessions-crash-rate-alerts)할 수도 있다.\n\n## track deploys 활성화\n- 배포 버전마다 모니터링 할 수 있도록 도와주는 기능이다.\n\t- Each release version (a short version of the release name without the hash)\n\t-  The associated project\n\t-  The adoption stage of each release\n\t-  The authors of each commit\n\t-  The percentage of crash-free users\n\t-  The percentage of crash-free sessions\n- [사전 작업](https://docs.sentry.io/product/releases/) 을 완료해야한다.\n\n## 불필요한 에러 수집 방지\n- 센트리 실행시 \b`ingnoreErrors` 매개변수를 전달하여 불필요한 에러 수집을 방지할 수 있다. 아예 센트리로 데이터를 보내지 않기 때문에 비용 측면에서도 개선된다. Next.js같은 프레임워크를 사용하여 애플리케이션을 운영하다보면 해결 불가능한 에러이지만, 유저 경험에는 영향을 끼치지 않는 로그들을 종종 마주친다. 그런 로그들을 추가하면 될듯 하다.\n\t```typescript\n\tSentry.init({\n\t\t...,\n\t\tignoreErrors: ['Failed to fetch']\n\t})\n\t```"},{"fields":{"slug":"/posts/regex/regex_01/","title":"정규표현식 - 01. 입문 정규표현식"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 정규표현식 - 01. 입문 정규표현식\ndate: 2022-03-27\nupdated: 2022-03-27\ntags:\n  - 정규표현식\n---\n\n> 다양한 언어로 배우는 정규표현식을 보고 제 나름대로 정리한 내용입니다.\n\n- 정규표현식이란, 수학에서 사용되는 식과 비슷하기 무언갈 표현하는 '식'이다.\n- 정규표현식에서는 구성요소와 연산자를 조합하여 식을 구성한다.\n\t- 구성요소\n\t\t-  수식의 숫자나 화학힉의 원소 기호에 해당하는 기호\n\t- 연산자\n\t\t- 수식의 덧셈 곱셉에 해당하는 기호\n\n\n## 정규표현 기본\n\n### 패턴과 일치\n- `x * (y+z)`  와 `x * y * z` 의 결과가 다른것처럼 정규표현식에서도 패턴에 대한 일치 따라 결과가 달라진다.\n\t- `1(0|1|2|3)`  vs `10|1|2|3`\n- 반복관련한 연산자를 **수량자**라고 부른다.\n\t- 전화번호는 `010-[0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]` 로 나타낼 수 있지만 수량자를 사용하면 `010-[0-9]{4}-[0-9]{4}` 로 표현 가능하다.\n\t- 여기서 수량자는 `{4}`\n\n### 메타문자와 구문\n- 정규표현식에서 특별한 의미를 지닌 문자를 **메타 문자** 라고한다.\n\t- e. g.  `()` , `|`, `*`, `{}`, `.`, `$`, `\\A`, `\\b`, `\\B`, `+`, `?`\n- 몇몇 메타 문자들은 다른 메타 문자와 리터럴과 함께 사용되어야만 의미를 가진다. 이런 작성법을 **구문**이라고한다.\n\n### 정규표현 엔진\n- 정규표현식 일치 처리를 담당하는 소프트웨어\n- 당연하게도 엔진이 다르면 지원하는 기능이나 구문도 달라진다. (언어마다 엔진이 다를 수 있다.)\n\n\n## 문자열과 문자열 처리\n\n### 컴퓨터와 문자열\n- 컴퓨터에서는 모든 데이터가 결국 2진수의 바이너리 형태로 처리된다.\n- 문자열은 데이터 구조가 간단하기 때문에 사람이 조작하기 쉽다.\n\n### 프로그래밍 단계\n- 실무에서 일상적으로하는 데이터 **검증**에 정규표현식은 자주 사용된다.\n- HTML5 내부에서 사용되는 `<input type=\"email\"/>` 의 정규표현식도 완벽하진 않다.\n\n### 유용한 작업들\n- 커맨드 라인 툴에 정규표현식을 사용하면 다양한 작업을 할 수 있다.\n\t- `sed` 을 통한 파일 내부 문자열 수정\n\t- `egrap` 을 통한 필요한 로그 문자열 추출\n\n\n## 기본 3연산: 집합, 선택, 반복\n\n###  패턴 연결\n- `/rs/` 는 `r` 다음에 `s`가 연이어 온다는 패턴을 나타낸다. 즉 순서대로 연결돼 있음을 의미한다.\n- 정규표현식을 연결하는 연산을 **집합**이라고 한다.\n\n\n### 패턴 선택\n- `/r|s/`는 `r` 또는 `s` 또는 둘을 연결한  `rs` 를 나타낸다.\n- `|` 로 나타내는 연산은 **선택** 또는 **합** 이라고한다.\n- `[](문자클래스)`를 활용해서 짧게 작성할 수도 있다.\n- 집합과도 조합이 가능하다\n\t- `(...)?` 라는 구문은 괄호내 패턴 또는 공백에 일치한다는 뜻이다.\n\t- `(r)?` 패턴은 `(r|)` 로 바꿔 쓸 수 있다. (공백문자열과 선택)\n\n### 패턴 반복\n- `\\d*`은 임의의 길이를 갖는 숫자를 의미한다.\n- `*` 반복연산은 정규표현식에 무한한 패턴을 나타낼 수 있는 능력을 준다. (클레이니 스타)\n\n\n### 기본 3연산의 조합\n- 각 3연산을 하나만 사용하는 경우\n\t- 접합만 사용\n\t\t- `abcd`처럼 하나의 문자열만 표현 가능\n\t- 선택만 사용\n\t\t- `0|1|2|3|4`처럼 '문자 하나'만 표현 가능\n\t- 반복만 사용\n\t\t- `0*` 처럼 어떤 문자의 반복만 표현 가능\n- 각 연산을 같이 사용하는 경우\n\t- 접합/선택 사용\n\t\t- 국립대학을 표현할 때 `제주대학|서울대학|강원대학` 등으로 표현가능하다.\n\n### 연산자 결합 순위\n- 3연산 사용시 각 연산자의 우선순의를 주의해야한다.\n- 우선순위\n\t1. 반복 (\\*)\n\t2. 접합 (두 단어를 잇는 행위)\n\t3. 선택 (|)\n- 제곱, 곱셈, 덧셈순으로 생각하자\n- 예를 들어 `hoge|fuga`라는 정규표현식을 반복하려면 `(hoge|fuga)*`처럼  사용해야한다. `hoge|fuga*`로 작성하면 반복 연산자의 우선순위가 더 높기 때문에 의도치 않은 결과가 나온다.\n\n\n## 정규표현식의 신택스 슈가\n정규표현식이 발전하면서 정규표현식 엔진은 신택스 슈가(syntax sugar)를 추가하여 필요한 기능들을 구현했다.\n\n### 더 편리한 구문에 대한 요구\n- 기본 3연산만으로는 복잡하게 작성해야했던 정규표현식들은 수량자, 점, 문자 클래스, 이스케이프, 앵커등이 추가되면서 더 간단하게 표현할 수 있게되었다.\n\n### 수량자\n- `*`\n\t- 0회 이상 임의의 횟수만큼 반복하는 연산자\n\t- 최근 정규표현식에는 `*`처럼 동작하는 다른 연산자들이 추가되었다.\n- `+`\n\t- 1회 이상 반복을 표현하는 연산자\n\t- 예를 들어 `ab+c`는 `ac`에는 일치하지 않고 `abbc`에 일치한다.\n\t- `(r)+`와 `r(r)*`이 가리키는 패턴은 완전히 동일하다 -> 여기서 `+`는 신택스 슈가이다.\n- `?`\n\t- 0회 또는 1회 반복을 표현하는 연산자\n\t- 수량자이며 물음표 연산이라고도 불린다.\n- `{n, m}`\n\t- n회부터 m회까지 반복해서 표현하는 연산자이다.\n\t- 범위 지정 반복제어, 범위 수량자라고 불린다.\n\t- `x{1,5}` 는 `x`, `xx`는 포함하지만 `xxxxxx`는 포함하지 않는다.\n\t- `m >= n` 조건을 만족하지 않으면 에러가 발생한다.\n- `.`\n\t- 임의의 한문자를 표현한다.\n\t- `r.*e` 는 앞이 `r` 끝이 `e`로 끝나는 모든 문자열에 일치한다.\n\n### 문자 클래스\n- 일련의 문자들을 패턴 안에 나타내고 싶은 경우 사용한다.\n- 문자 클래스는 `[]`안에 표현하고 싶은 문자를 넣으면 된다.\n- 예시\n\t- 0~9: `[0-9]`\n\t- a~z: `[a-z]`\n\t- A~Z: `[A-Z]`\n\n- 문자 클래스 범위 지정\n\t- `-`를 통해 범위를 지정한다.\n\t- 문자 클래스의 범위 지정은 [아스키 코드](https://ko.wikipedia.org/wiki/ASCII)의 순서를 따른다.\n\t- `-`라는 문자 자체를 문자 클래스 안에 넣고 싶은 경우, 문자 클래스 맨 뒤, 맨 앞에 기입하자.\n- 부정\n\t- `^`는 문자 클래스 내부에서 부정(not)으로 작동한다.\n\n\n### 이스케이프\n- 탭 문자, 줄바꿈 문자 등 표시 불가능한 문자는 이스케이프(`\\`)를 통해 나타 낼 수 있다.\n\t- 이스케이프 문자들은 아스키 코드에서 확인 가능하다.\n- 문자 클래스 내부에서 사용되는 메타 문자(`*`, `^`, `-` 등)을 문자로써 사용하려면 앞에 이스케이프 처리를 하면 된다.\n\n### 앵커\n- 문자열이 아닌 위치에 일치하는 메타 문자이다.\n- 예를 들어 '행 처음'에 일치하거나 '행 끝'에 일치하는 부분을 찾을 때 사용한다.\n- 주요 앵커\n\t- `^`\n\t\t- 행 처음\n\t- `$`\n\t\t- 행 끝\n\t- `\\A`\n\t\t- 텍스트 선두\n\t- `\\b`\n\t\t- 문자열 사이\n\t- `\\B`\n\t\t- 문자열 사이 외\n\t- `\\z`\n\t\t- 텍스트 끝\n\t- 문자열 사이라는게 무슨 말일까?\n\t\t- 정규표현식에서는 문자와 문자사이 빈 영역도 하나의 문자로 평가한다\n\t\t\t- `abc`\n\t\t\t\t- a와 b사이, b와 c사이에는 공백문자열이 존재하는 것이다. 우리가 글자를 입력할 때 생기는 커서를 생각해보자\n\n\n## 캡쳐와 치환: 정규표현식으로 문자열을 조작한다.\n\n\n### 문자열 부위: 접두사, 접미사, 부분 문자열\n\n### 일치의 종류\n\n### 서브 패턴과 서브 매치\n\n### 캡쳐\n\n### 캡쳐 없이 그룹화\n\n\n### 서브 매치의 우선순위\n\n### 정규표현식을 이용한 문자열 치환\n\n### 문자열 치환 툴\n\n\n## 정규표현식의 확장 기능: 전방 탐색/재귀/역참조\n\n### 전방 탐색\n\n### 재귀\n\n### 역참조\n\n### 기본 3연산으로 표현할 수 없는 패턴\n\n\n\n\n## 정규표현식의 엔진의 기본\n\n### 정규표현식 엔진의 종류 (DFA형과 VM형)\n\n\n### DFA형 키워드: 결정성과 비결정성\n- DFA\n\t- 결정성 유한 오토마타\n- NFA\n\t- 결정성을 가진 유한 오토마타와 갖지 않는 오토마타를 통틀어서 말하는 것\n\n### 유한 오토마타로 정규표현식에 대한 이해를 높인다\n\n### VM형 키워드: 백트랙\n\n### 다음 장 이후부터의 내용 구성\n"},{"fields":{"slug":"/posts/regex/regex_03/","title":"정규표현식 - 03. 프로그래머를 위한 고급 정규표현식"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 정규표현식 - 03. 프로그래머를 위한 고급 정규표현식\ndate: 2022-03-27\nupdated: 2022-03-27\ntags:\n  - 정규표현식\n---\n\n> 다양한 언어로 배우는 정규표현식을 보고 제 나름대로 정리한 내용입니다.\n\n3장에서는 접합/선택/반복의 기본 3연산만으로 구성되는 정규표현식으로 기술할 수 있는 패턴이 무엇인지 설명한다. -> 기본부터 잘 알아야한다.\n- 기본 3연산만으로 구성되는 정규표현식으로 기술할 수 있는 패턴 -> [[정규 언어]]\n\t- 정규표현식의 패턴은 단어라는 의미이다.\n\n\n\n## 단순한 정규표현식과 정규언어\n정규표현식에 일치하는 문자열의 집합 = 정규 언어\n\n\n### 집합의 기준\n- `a*b*` 라는 정규표현식에 일치하는 문자열\n\t- 공백문자열, ab, aab, aabb...  무한히 존재함 -> `a*b*` 정규 언어는 무한히 존재한다.\n\n\n### 문자 집합\n- **집합**이란 무언가를 모아놓은 것을 뜻한다.\n\t- **문자 집합**\n\t\t- 심볼 또는 기호들로 이루어진 집합\n- 우리는 10진수로 숫자를 표현할 때 {1,2,3,4,5,6,7,8,9,0}을 사용하며 이는 아스키 코드 집합에 속해져 있는문자들이다.\n- 전세계 문자를 처리하는 표준 규격 유니코드는 113021개의 문자가 등록되어있다.\n- 지금까지 열거한 문자 집합들은 모두 문자의 종류가 **유한**하다는 공통점이 있다.\n\t- 집합론에서는 `문자 집합은 유한 집합이다`라고 한다.\n\n\n### 문자열 집합\n$\\sum^*$\n-   이 기호는 문자집합  $\\sum$을 조합하면 만들어낼 수 있는 `모든 문자열`의 집합을 나타낸다.\n- $\\sum^*$는 $\\sum$상의 모든 문자열의 집합이다.\n- 단, 여기서말하는 문자열은 유한 개수만큼 나열한 것이라고 생각하자.\n- $\\sum = \\{0, 1\\}$의 $\\sum^*$은 $\\{0, 1, 00, 11, 10, 01, 100, ...\\}$ 이다. 즉, 모든 바이너리 문자열 집합을 의미한다.\n- $\\sum^*$ 는 공백 문자열을 포함한다.\n\t- 아무것도 없는 문자열도 문자열로 처리한다는 뜻이다. 이 책에서는 공백문자를 입실론($\\mathcal{E}$)으로 표기한다.\n\t- $w$를 0회 반복한 문자열은 공백문자열이다.\n- $\\sum^*$ 는 무한 집합이다.\n\t- 무한한 요소를 가지기 때문에 얼마든지 길어질 수 있다.\n\t- 집합론에서는 무한 집합이라고 한다.\n\n### 집합의 작성법: 외연적 기법과 내포적 기법\n- 외연적 기법\n\t- $\\{\\}$안에 모든 요소를 열거\n- 내포적 기법\n\t- $\\{n|n은 0 이상 10 이하의 자연수\\}$\n\t- 함수와 비슷한 꼴이다.\n\n\n### 언어 = 문자열집합\n- 형식 언어 이론에서는 문자 집합 $\\sum$ 상의 언어란 문자열 집합 $\\sum^*$ 의 부분 집합을 가리킨다.\n\t-  `a` 는 `a*`에 포함되듯?\n- 이 책에서는 `계산적/수리적으로 기술할 수 있는 언어`를 중점으로 다룬다.\n\t- 계산적/수리적으로 기술\n\t\t- 불가한 케이스\n\t\t\t- 바른 문법의 한글\n\t\t- 가능한 케이스\n\t\t\t- $\\{ w | w 는  0^*(10^*10^*)에 일치하는 문자열\\}$\n\t\t\t\t- 짝수개의 1을 포함하는 바이너리 문자열을 뜻한다.\n\n\n### 단순한 정규 표현식\n- 초기 정규표현식에는 기본 3연산인 접합/선택/반복 이 세가지 연산밖에 없었다. 물론 이 연산만으로도 URI처럼 복잡한 패턴을 표현할 수 있다.\n- 정규표현식을 집합으로 표현하기\n\t- 임의의 정규표현식 `r`, 그 `r`에 일치하는 문자열 집합 `L(r)`, `L(r)`은 `r` 의 수락 문자열 집합이라고 부르기로 한다.\n\t- `1(0|1)0`이라는 정규표현식을 예시로 들어보면\n\t\t- $L(1(0|1)0) = \\{100,110\\}$\n\t- 일반적으로  반복연산자인 `*`(클레이니 연산자)를 포함하는 경우에는 `r`에 일치하는 문자열 집합은 무한 집합이 된다.\n\n### 정규표현식으로 표현할 수 있는 언어\n- 정규표현식으로 표현할 수 있는 언어 === 정규 언어\n- 모든 정규 언어에는 반드시 그것을 표현하는 정규표현식이 존재하며, 정규표현식은 정규 언어를 표현하기 위한 방법중 하나일 뿐이다. 이외에도 유한 오토마타, 유한 모노이드 등이 있다.\n\n\n\n## 현대 정규표현식의 다양한 기능/구문/구현\n기본 3연산인 접합/선택/반복외의 다양한 기능을 설명한다.\n\n\n### 정규표현식의 다양한 기능 추가 흐름과 다양하 엔진이 존재하는 이유\n- 정규표현식의 기능 추가 흐름은 개발 역사와 맞물려 있는데, 개발이 고도화되며 각기 다른 목적의 정규표현식 엔진들이 만들어지게 되었다.\n\n### 정규표현식 엔진간 기능 구현/구문 차이\n- 30종이 넘는 유명한 정규표현식 엔진이 존재하지만, 주요 정규 표현식 엔진들은 다음과 같다.\n\t- 펄\n\t- PCRE\n\t- 루비\n\t- 자바스크립트\n\t- Google RE2\n\t\t- 참고로 구글의 [제프딘](https://namu.wiki/w/%EC%A0%9C%ED%94%84%20%EB%94%98)이 참여했었다.\n\t- GNU grep 등\n- 엔진마다 지원하는 기능들이 각자 다르다.\n\t- 캡쳐 관련 기능/구문\n\t\t- 참고로 최근 자바스크립트 스펙에서는 [이름 지정 캡쳐 기능](https://www.smashingmagazine.com/2019/02/regexp-features-regular-expressions/)이 추가되었다.\n\t- 확장 기능인 전방/후방 탐색\n\t- 재귀\n\t- 역참조\n- 각 정규표현식 엔진들의 구조를 이해하게되면 성능최적화를 하는데 큰 도움이 되기 때문에 어떤 구조로 동작하고 있는지 알아 두는것이 좋다.\n\t- 크게 두 종류로 나누는 엔진 종류\n\t\t- DFA\n\t\t\t- 속도 중심\n\t\t- VM\n\t\t\t- 기능 중심\n\n### 기본 엔진의 벤치마크\n- 자바스크립트 업계에서는 JIT 컴파일을 도입하면서 서로간의 엔진 경쟁이 심해졌다. 이는 webkit을 프로젝트를 시작한 애플이 가장 먼저 도입하면서 시작되었다.\n- 엔진의 종류마다 탄생하게된 목적이 다르듯 정규표현식마다 특정 엔진이 우세한 성능을 보인다.\n- 특정 정규표현식은 특정 엔진에 엄청난 성능 부하를 일으키기도 한다.\n\t- `a[^x]{20}b` 를 DFA 엔진에서 사용하면 상태 수 폭발로 인해 엄청 느리다.\n\n\n## 읽기 쉬운 정규표현식 작성\n정규표현식을 깊게 이해해도 결국 읽기 실무에서는 읽기 쉬운 정규표현식을 작성해야한다.\n\n\n### 간단히 작성하기\n- `.*hoge.*fuga.*piyo.*|.*hoge.*piyo.*fuga.*|.*fuga.*hoge.*piyo.*|.*fuga.*piyo.*hoge.*|.*piyo.*hoge.*fuga.*|.*piyo.*fuga.*hoge.*|`\n\t- 위 정규표현식은 전방 탐색을 통해 AND 연산으로 짧게 대체할 수 있다.\n\t\t- `(?=.*hoge.*)(?=.*fuga.*)(?=.*piyo.*)`\n\t\t\t- 전방탐색후 다음 전방탐색 그룹에게 커서를 넘기고 다시 커서를 되돌리며 검색한다. (루프처럼 동작)\n- 가독성 좋은 정규표현식 작성하기\n\t- 그룹화, 수량자, 문자 클래스, 이스케이프를 활용하자\n\t\t- `02-[0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]`는 `02(-\\d{4}){2}`로 작성할 수 있다.\n\t- 전방 탐색이나 후방 탐색 기능을 적극 활용하자.\n\t\t- 단 팀원들이 이 기능을 이해하고 있다는 전제하에 사용해야 한다.\n\t- 정규표현식을 부품화 하자.\n\n### 설명 형식으로 적기\n-  정규표현식도 설명 형식으로 작성가능하다.\n\t- 이름 지정 캡쳐 사용하기\n\t\t- `DD/MM/YYYY`\n\t\t\t- `(\\d{2})\\/(\\d{2})\\/(\\d{4})`\n\t\t\t\t- 뭐가 뭔지 한눈에 안들어온다.\n\t\t\t- `(?<day>\\d{2})\\/(?<month>\\d{2})\\/(?<year>\\d{4})`\n\t\t\t\t- 아 날짜 문자열이구나~\n\t\t\t- 아래와 같은 방법도 가능하다.\n\t\t\t```\n\t\t\t/\n\t\t\t\t(\\d{2}) \\/ # 일\n\t\t\t\t(\\d{2}) \\/ # 월\n\t\t\t\t(\\d{4})    # 년\n\t\t\t/\n\t\t\t```\n\n\n\n\n\n## 현실적으로 타협하기\n이 세상에는 도대체 이런 정규표현식을 누가짠거야? 라는 생각이 들 정도로 복잡한 정규표현식이 많이 존재한다.\n\n\n### 엄격한 정규표현식\n- 이메일은 작성하는 사람의 입장에서는 간단한 패턴으로 이루어진 문자열이지만, 이를 위한 정규표현식은 매우 복잡하다.\n- HTML5에서는 이메일 검증을 위해 다음 정규표현식을 사용한다.\n\t```\n\t/^[a-z0-9!#$%&'*+\\/=?^_`{|}~.-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/iD\n\t```\n- RFC 정의 표준에는 이 정규표현식이 표준 문법을 따르지 않다고 강조하고 있다. 그 이유는 실용성 때문이다. RFC의 사양을 읽고 제대로 해석하는 것부터 어려우며 메일 주소 문법을 제대로 쉽게 설명하는 사이트도 찾기 힘들다. HTML5가 제공하는 이메일 정규표현식이 오히려 메일 주소 정규표현식의 표준을 제공하는게 오히려 도움이 되는 것이다.\n- 서울의 전화번호를 **엄격**하게 제한하려면 `02(-\\d{4}){2}`로 작성하면 된다. 하지만 모든 번호를 포함하지는 못한다. 시내 국번을 포함하거나 앞자리가 3자리인 경우도 있다. 물론 모든 전화번호를 나열하면 정규표현식을 만드는것이 가능하다. 비슷하게 세상에 존재하는 모든 URI도 정규표현식을 만드려면 모든 URI에 request를 보낸 후 응답이 있는 URI를 나열하여 정규표현식을 만들 수 있다. 그런데 이는 매우 비효율적이다.\n\n### 절충형 정규표현식\n- 어느 정도 복잡성을 가진 패턴을 작성하는 것은 도구의 힘을 빌려야한다. 아니면 절충하여 사용하고 있는 언어의 힘을 빌려야한다.\n\t- 예시)  if문으로 먼저 큰 패턴을 제외시킬 수 있다.\n- 절충형 정규표현식 작성시 선택해야할 점\n\t- 맞는 문자열에 일치한다 -> false nagative\n\t- 맞지 않는 문자열에는 일치하지 않는다. -> false positive\n- false nagative\n\t- 표현하고 싶은 언어에 포함되는 더 작은 언어를 유사하다고 간주한다. -> 더 작은 범주 -> 통과해야할게 통과 못할 수도 있다.\n- false positive\n\t- 표현하고 싶은 언어를 포함하는 더 큰 언어를 유사하다고 간주한다. -> 더 큰 범주 -> 통과하면 안되는게 통과할 수도 있다\n- 실무에서는 false negative를 사용하는것이 좋다."},{"fields":{"slug":"/posts/regex/regex_02/","title":"정규표현식 - 02. 정규표현식의 역사"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 정규표현식 - 02. 정규표현식의 역사\ndate: 2022-03-27\nupdated: 2022-03-27\ntags:\n  - 정규표현식\n---\n\n> 다양한 언어로 배우는 정규표현식을 보고 제 나름대로 정리한 내용입니다.\n\n\n## 정규표현시의 기원\n- 정규표현식으로 대두되는 사람은 연구자 클레이니이다.\n- 정규표현식이 만들어내기 전까지는 계산이란 무엇인가? 라는 근원적인 연구가 진행되어 있었고, 계산이라는 행위 자체에 대한 부분을 수학적으로 정형화 한것이 \"계산 모델\"이다.\n- 계산 모델에 대한 기념비 적인 두 연구는 튜링머신과 형식적 뉴런이 있다.\n\n\n### 튜링 머신과 알고리즘\n- 과학자 튜링이 발명한 튜링머신은 계산기 모델이지만 실질적으로 계산할 수 있는 모든 것들을 머신이 계산할 수 있도록 하는게 목적이였음\n- 계산할 수 있다는 것은 결과가 정성적인게 아닌 정량적인 것\n\t- 인생이란 무엇인가? X\n\t- 주어진 수가 소수인가? O\n- 대부분 알고리즘을 \"계산기가 계산하기 위한 순서\"로 알고 있지만 \"튜링 머신으로 실행할 수 있는 것\"이 알고리즘이다.\n\n\n### 뇌의 계산 모델과 형식적 뉴런\n- 1943년에 연구된 형식적 뉴런 계산 모델은 튜링 머신과 다르게 뇌과학적/신경생리학적 접근으로 만들어 졌다.\n- 노드 사이가 연결되어 있고 각자 입력에 가중치가 부여되 있다.\n- 형식적 뉴런이 확립되고 난 후부터 뉴럴 네트워크 연구가 활발해졌다. (이게  정규식이랑 뭔 관련이 있는지는 모르겠다)\n-\n\n\n## 클레이니에 의한 통일\n\n### 기억 영역의 유무: 형식적 뉴런과 튜링 머신의 결정적 차이\n- 형식적 뉴런과 튜링머신에는 기억 영역의 유무의 차이게 있기에, 튜링머신 즉, 알고리즘은 세상에 존재하는 모든 문제를 계산할 수 없다.\n\t- 기억 영역 : 메모리나 하드 디스크로써 계산시 사용될 수 있는 외부 작업영역\n- 1951년 클레이니는 형식적 뉴런이 정규표현식과 같은 것임을 밝혀냈다.\n\n### 정규표현식의 탄생\n- 클레이니는 과거 눈문에서 정규표현식 (regular expression)을 제안했다.\n\t- 형식적 뉴런으로 계산할 수 있는 것은 정규표현식으로도 표현할 수 있다는 내용으로 regular expression 명칭도 논문에서 제안했다\n\t- 아래는 클레이니 논문에 기재된 등식을 최근 정규표현식 구문으로 바꾼것이다\n\t\t- E|E = E\n\t\t- E|F = F|E\n\t\t- (E|F) G  = E|(F|G)\n\t\t- (EF)G = E(FG)\n\t\t- (E\\*F)G = E\\*(FG)\n\t\t- (E|F)G = EG|FG\n\t\t- E(F|G) = EF|EG\n\t\t- E\\*(F|G) = E\\*F|E\\*G\n\t\t- E\\*F = F|E\\*EF\n\t\t- E\\*F = F|EE\\*F\n\t\t- E\\*F = E^s\\*(F|EF|E^2... E^(s-1)) (s>=1)\n\n### 유한 오토마타 도입\n- 위의 논문에서 정규표현식 바로뒤에 유한 오토마타라는 계산 모델을 도입했다.\n\t- 유한 오토마타\n\t\t- 기억 영역이 없는 계산 모델\n\t\t- 형식적 뉴런보다 단순하게 표현한 계산모델\n\t\t- 유한 오토마타가 계산할 수 있는 것 === 정규표현식으로 표현할 수 있는 것\n\t\t\t- 메모리를 일절 소비하지 않는 프로그램으로 계산할 수 있는 것\n\t\t- 오토마타라는 단어는 중세 유럽에서는 태엽으로 움직이는 인형이라는 뜻을 가졌음.\n\n### 유한 오토마타 이론의 발전\n- 지금 까지도 오토마타 이론이라는 분야는 활발히 연구되고 있다.\n- 오토마타와 정규표현식은 뗄 수 없는 관계이다.\n- 오토마타를 사용하면 다음 두 개의 문제를 쉽게해결할 수 있다.\n\t- 2개의 정규표현식이 같은지 판정\n\t- 정규표현식을 부정 정규표현으로 만들기\n\n\n## \\[적응편\\] 프로그래머의 친구\n학문적 세계에서 탄생한 정규표현식이 대중들에게 알려지게된 계기는 유닉스였다.\n\n### 최초의 정규표현식 엔진\n- 클레이니의 논문 이후 17년이 지나고 케네스 톰슨은 정규표현식을 다룬 첫 논문을 발표했다. 해당 논문에는 다음과 같은 내용을 담고있다.\n\t- 정규표현식으로 NFA를 구성하는 방법\n\t\t- 톰슨 구성법이라고도 불린다.\n\t- NFA 를 효율적으로 시뮬레이션 하는 방법\n\t\t- NFA? [[regex_01#DFA형 키워드 결정성과 비결정성]]\n\t\t- NFA를 효율적으로 시뮬레이션 하는 방법은 톰슨 NFA라고 부른다.\n\t- 시뮬레이션을 실행하는 IBM 7094 코드를 직접 생성하는 방법\n\t\t- 정규표현식의 JIT컴파일러를 만들어냈음을 의미한다.\n\n### QED: 정규표현식을 이용한 검색 가능한 텍스트 편집기 등장\n- 1960년 후반 C언어도 없던 시대에 메인프레임상에서 동작하는 버클리 시분할 시슽메은 QED라는 편집기를 사용하고 있었다. 톰은은 QED를 IBM 7094로 이식하는 작업을 맡았다.\n- 이 때 추가된 기능중 하나는 정규표현식을 사용한 검색 기능이다.\n\n### ed 에디터부터 grep까지\n- 1971년 톰슨은 유닉스에 탑재하기 위한 에디터로 ed를 개발했는데 이는 최초의 유닉스 정규표현식 툴이다.\n\t- ed의 정규표현식 엔진에서는 선택기능을 사용할 수 없었다.\n\t- `Ken|Thompson`  이런게 불가능\n\t- 작동방법이 매우 불편하다. `man ed`를 통해 설명을 확인할 수 있다.\n\t\t- 파일명을 입력 -> 명령어 실행 -> 내용 표시 -> 커서를 통해 원하는 곳 수정\n- ed는 vim과 마찬가지로 입력/명령어모드로 나누어져 있다.\n- ed는 line editor이고 vim은 screen editor이다.\n\t- ed는 행을 지향한다.\n\t\t- 과거에는 출력물이 디바이스의 화면이 아니라 텔레타이프라는 기계를 통해 종이에 표현됐었다. vim처럼 전체화면을 안보여준 이유가 다 있다.\n\t\t- 오늘날에는 editor를 떠올리면 screen editor를 떠올리는게 당연하기 때문에 앞에 line, screen따위는 붙이지 않는다.\n- 정규표현식이 일치하는 행을 찾는 기능도 편했지만, 검색을 위해 편집기를 켜야하는 점과 실수로 파일내용을 건드릴 위험이 있다는 단점 때문에 grep이라는 도구가 탄생했다\n\t- 참고로 ed에서 RE라는 정규표현식에 일치하는 행을 모두 표시하는 명령은 `g/RE/p`이다. (grep의 이름 유래)\n\n### 유닉스와 정규표현식\n- grep이후 AWK, sed, find 등 다양한 정규표현식을 활용한 툴이 등장했다. 현재에도 정규표현식을 사용하는 툴을 열거하면 끝이없을 정도로 많다\n\n\n## 프로그래밍 언어와 정규표현식의 만남\n- 정규표현식은 문자열 검색을 위해 만들어졌지만, 프로그래밍이란 더  큰 영역으로 진출하게 됐다.\n\n\n### 범용 프로그래밍 언어로서 진출: AWK\n- AWK는 가장 빠른 시기에 정규표현식을 도입한 범용 프로그래밍언어이다.\n\t- (cli에서 사용가능한 단순한 프로그램인줄 알앗는데 언어였다..)\n- 1985년에 업데이트를 통해 패턴 일치 기능을 도입했다.\n\n### POSIX를 이용한 표준화\n- 1980년에는 구현 호환성을 확보하기 위해 POSIX(Portalbe Operatiing System Interface)라는 운영체제 전반에 관련된 규격이 생겼다.\n- 정규표현식에도 POSIX 표준사양이 정해졌고, 그 당시 C언어와 PHP에서 사용하는 정규표현식이 POSIX.2를 기준으로 하고 있었다.\n- POSIX 정규표현식\n\t- BRE (표준 정규표현식)\n\t\t- GNU grep\n\t\t- 선택연산, +,? 수량자 사용불가\n\t- ERE (확장 정규표현식)\n\t\t- grep의 -e 옵션, egrep\n\n### 헨리 스펜서의 정규표현식 라이브러리\n- 헨리스펜서는 최초의 C 언어용 정규표현식 라이브러리를 만들어 배포했다. 이 덕분에 개별적으로 엔진을 만들필요가 없이 패턴 일치  기능을 사용할 수 있게되었다.\n\n\n## 최근의 정규표현식 엔진 현황\n- [[regex_01#정규표현식 엔진의 종류 DFA형과 VM형]] 에서 보앗듯 정규표현식의 대부분은 VM형과 DFA형 엔진으로 구분된다.\n- DFA\n\t- GNU grep\n\t- Google RE2\n- VM\n\t- 펄, 자바스크립트, 루비에 탑재된 엔진\n\n\n### GNU grep\n- grep은 ed의 정규표현식 검색 기능을 개별로 빼낸것이다.\n- `tail -n 100 log.txt | grep 'error'`\n\t- 위 명령어는 log.txt란 파일에서 error라고 적힌 행을 뒤부터 100줄까지만 검색하여 출력하는 명렁어이다.\n\t- `|` 는 파이프라고 부르며 맥클로이라는 사람이 처음 고안한 아이디어이다.\n- 파이프는 매우 편리한 도구였고 여러곳에 영향을 끼치게된다.\n- GNU grep은 본적으로 DFA형이지만, 역참조 대응을 위해 부분적으로는 VM형 접근법도 사용한다.\n- DFA형의 중요한 부분은 성능이다.\n\n### Google RE2\n- 러스 콕스가 C++로 만든 정규식 라이브러리로 2013년에 출시된 가장 새로운 부류이다.\n- 구글에서 전 세계 오픈소스를 검색하기위해 만들었다.\n- GNU grep가 비교해도 손색이 없는 성능이지만 역참조나 재귀 기능을 제공하지 않는다. (오토마타 이론에서는 이런 방침이 옳다고 할 수 있다.)\n\n### Perl\n- 래리 월이 실무에서 필요에 의해 만든 실천 지향 언어이다.\n- rn이라는 툴의 정규표현식을 빌려와 만들었을 땐 빈약한 기능을 가졌지만 차차 개선됐다.\n\n### PCRE\n- 여러 언어에서 Perl 정규표현식을 도입하는데 도움을 준 호환성이 높은 정규표현식 패키지이다.\n- 나중에는 펄의 정규표현식에는 없는 JIT을 도입해 고속화를 실현했다.\n\n### 자바스크립트\n- 자바스크립트에 사용되는 정규표현식은 ECMAScript에 엄격하게 정해져 있다.\n- 브라우저의 자바스크립트 엔진에서는 속도향상을 정규표현식을 최적화한다.\n\t- 대부분의 컨턴츠를 텍스트로 주고 받기 때문\n- JIT 컴파일이라는 기법이 정규표현식 엔진에 적용되었다.\n"},{"fields":{"slug":"/posts/regex/regular-language/","title":"정규언어"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 정규언어\ndate: 2022-09-27\nupdated: 2022-09-27\ntags:\n  - 정규언어\n---\n\n- 토큰의 형태를 기술하는데 사용하는 언어.\n- 정규 언어를 표현하는 방법\n\t- 1.정규 문법(regular grammer)\n\t- 2.정규 표현(regular expression)\n\t- 3.유한 오토마타(finte automata)가 있다."},{"fields":{"slug":"/posts/seo/nextjs dynamic sitemap/","title":"next.js SEO 개선하기"},"frontmatter":{"draft":true},"rawBody":"---\ntitle: next.js SEO 개선하기\ndate: 2022-11-09\nupdated: 2023-05-27T19:10:55+09:00\ntags:\n  - SEO\ncreated: 2022-11-09T11:28:03+09:00\ndraft: true\n---\n\n## 목표\n- 기존에 next router들에 대한 정보만 존재하던 간단한 sitemap에 상세페이지들에 대한 정보를 추가한다.\n- SEO가 개선되어야할 페이지로 접근시 url에 서치키워드를 추가하여 리다이렉션 한다.\n\n\n## 문제 해결과정\n\n### 레퍼런스 찾기\n일반적인 url 접근시 서치키워드를 붙여주는 ux는 stackoverflow의 질문답변 페이지에서 확인할 수 있습니다.\n\nhttps://stackoverflow.com/questions/31079081 접근시\n\nhttps://stackoverflow.com/questions/31079081/programmatically-navigate-using-react-router 로 url이 변경됩니다.\n\n뒤에 붙은 `programmatically-navigate-using-react-router`은 질문 타이틀에 있는 공백과 특수문자를 `-`로 치환시킨것과 동일합니다.\n\n\n### sitemap 업데이트 하기\n\nstackoverflow처럼 URL을 변경해주는 부분을 프론트엔드 코드에서 로직을 추가한다고 해서 SEO에 영향은 없기 때문에 몇가지 작업이 필요합니다. 그중 하나는 sitemap에 대한 업데이트입니다.\n\nsitemap은  [[robots.txt]] 에 명시되어 크롤러에게 사이트의 구조를 알려주는데 사용됩니다.\n\nnext.js는 `pages`폴더 하위에 만들어진 파일들을 기반으로 `publiic` 폴더에 sitemap을 생성해줍니다. \n\n[next-sitemap](https://github.com/iamvishnusankar/next-sitemap)은 SEO에 필요한 `sitemap.xml`, `robots.txt` 파일들을 관리하는걸 도와줍니다.\n\n#### 설치\n```\nyarn add next-sitemap\n```\n\n\n#### 사용방법\n\n1. root에 `next-sitemap.config.js` 생성\n```javascript\n/** @type {import('next-sitemap').IConfig} */\nmodule.exports = {\n  siteUrl: process.env.SITE_URL || 'https://example.com',\n  generateRobotsTxt: true,\n}\n```\n\n2. package.json - script 추가\n```json\n\"build\": \"next build && yarn postbuild\",\n\"postbuild\": \"next-sitemap\"\n```\n\n3. 이제부터 `yarn build` 실행시 `next-sitemap`을 통해 sitemap이 생성됩니다.\n\n#### dynamic sitemap\nSEO를 개선할 페이지의 URL이 정적이지 않은 경우, 동적인 sitemap을 제공해야합니다. \n\n동적인 sitemap을 제공하기 위한 라우터를 추가하기 위해 `pages` 디렉토리에 `server-sitemap.xml/index.tsx` 파일을 생성해주세요.\n\n\n```tsx\n\n\nexport const getServerSideProps: GetServerSideProps = async (ctx) => {\n\t// 데이터를 호출합니다.\n\tconst fields = response.map(({ id, title }) => ({ id, title })).map(\n\t\t({ id, title }) => {\n\t\t\t\treturn {\n\t\t\t\t\tloc: `https://example.com/detail/${id}/${title}`, // seo의 대상이되는 url\n\t\t\t\t\tlastMod: new Date().toISOString(),\n\t\t\t\t};\n\t\t\t});\n\n\t\t\treturn getServerSideSitemap(ctx, fields);\n\t\t}\n\t);\n};\n\nconst SitemapXML = () => {\n\treturn null;\n};\n\n\n\nexport default SitemapXML;\n```\n\n\n이제 `/server-sitemap.xml`에 접근하면 다음과 같이 사이트맵이 생성된걸 확인할 수 있습니다.\n\n![[sitemap01.png]]\n\n\n\n그리고 동적으로 생성된 sitemap이 있기때문에 이 부분을 `next.config.js` 설정에 명시해야합니다.\n\n\n```javascript\n\n/** @type {import('next-sitemap').IConfig} */\nmodule.exports = {\n  ...\n  exclude: ['/server-sitemap.xml'], // 정적인 사이트맵 리스트에서 제외\n  robotsTxtOptions: {\n    policies: [\n      {\n        userAgent: \"*\",\n        disallow: [''], // 크롤링하면 안되는 페이지 pathname을 나열합니다.\n      }\n    ],\n    additionalSitemaps: [\n      `https://example.com/server-sitemap.xml`, // 동적으로 생성되는 사이트맵 포함\n    ],\n    transformRobotsTxt: async (_, robotsTxt) => `${robotsTxt}\\n\\n${customOptions}`, // robots.txt를 커스터마이징할 때 사용함\n  },\n}\n\n```\n\n\n### Next.js 리다이렉션 추가\n사이트맵은 유저나 크롤러가 접근했을 때 브라우저에서 URL을 바꾸는 역할을 하진 못합니다.\n리다이렉션 동작을 코드상에 추가해줘야합니다.\n\nNext.js를 사용하는 경우, 리다이렉션은 서버 요청을 제어할 수 있는 `getServersideProps` 에서 가능합니다.\n\n```typescript\n\nconst needRedirect = URL이_유효하지_않은가?\n\nif (needRedirect) {\n\treturn {\n\t\tredirect: {\n\t\tdestination: SEO를_위한_pathname,\n\t\tpermanent: true, // 308 redirect\n\t};\n}\n```\n\n\n이제 SEO를 위한 suffix가 적용되지 않은 URL로 접근시, destination으로 지정한 URL로 리다이렉션됩니다. 크롬 개발자도구를 열어 network탭을 확인하면, 아래처럼 status code가 바뀌어 있는걸 확인하실 수 있습니다.\n\n![[redirection_308.png]]\n\n\n#### 상태코드로 308을 쓰는 이유\n\n![[308-Permanent-Redirect.png]]\n\n\n\nstackoverflow의 질문답변 페이지에서는 리다이렉션시 301 상태코드를 사용중입니다. 하지만 Next.js 공식사이트에서는 리다이렉션시 301(Moved Permanently) 대신[ 307(Temporary Redirect), 308(Permanent Redirect) 상태코드를 사용할 것을 권장](https://nextjs.org/docs/api-reference/next.config.js/redirects)하고 있습니다.\n\n그 이유는 동작방식의 차이에 있습니다. 301 상태코드로 리다이렉트를 하는 경우, Request의 Method와 상관없이 GET 요청으로 변경합니다. 리다이렉션되는 요청이 GET Method가 아닌 경우 유저가 의도하지 않은 Method로 변경될 수 있고, 유저가 보낸 payload가 유실될 수 있기때문에 Next.js에서는 301 리다이렉션을 권장하지 않습니다.\n\n\n## 아쉬운 점\n현재 구조로는 `server-sitemap.xml` 을 조회할 때마다 서버에서 api를 호출하는 구조입니다. 현재는 서비스에서 사용되는 데이터의 양이 적어 문제가 되지않지만, 데이터가 많아지게되면 불필요한 조회들와 연산들이 많아져 문제가 생길수 있을것 같습니다. 캐싱을 추가하고 요청이 생길 때만 해당 캐시를 무효화하는 방식이 필요해보입니다.\n\n\n## 참고링크\n- https://medium.com/volla-live/next-js%EB%A5%BC-%EC%9C%84%ED%95%9C-sitemap-generator-%EB%A7%8C%EB%93%A4%EA%B8%B0-10fc917d307e\n- https://www.zodaland.com/tech/16\n- https://www.sitemaps.org/ko/protocol.html\n- https://moonsupport.oopy.io/post/11\n- https://stackoverflow.com/questions/2594179/multiple-sitemap-entries-in-robots-txt\n- https://nextjs.org/docs/api-reference/next.config.js/redirects\n- https://velog.io/@himprover/Nextjs-Redirect-%EC%98%B5%EC%85%98%EC%97%90-Permanent%EB%8A%94-%EB%AD%90%EC%A7%80#301-302%EC%99%80-307-308%EC%9D%98-%EC%B0%A8%EC%9D%B4\n- https://nextjs.org/docs/routing/dynamic-routes#optional-catch-all-routes\n- https://www.infidigit.com/news/308-redirects-for-seo-are-they-better-than-301/\n"},{"fields":{"slug":"/posts/tip/chatgpt/","title":"혼자 알기 아까운 chatgpt 활용 꿀팁"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 혼자 알기 아까운 chatgpt 활용 꿀팁\ndate: 2023-05-01\nupdated: 2022-11-17T22:40:14+09:00\ntags:\n  - chatgpt\ncreated: 2022-11-17T22:40:14+09:00\n---\n\n- 면접 준비하기\n\t- 이력서의 일부분과 직무, 채용공고 등의 내용을 전달한다.\n\t- 이를 바탕으로 나올 수 있는 면접 질문을 만들어달라고 요청한다.\n- 편한 함수 구현\n\t- 인수조건이 담겨있는 문서에서 일부 로직이 분기처리 표현을 bullet 스타일로 잘 해놨다면 해당 문구를 복사하고, 적당한 이름으로 함수명을 작성한다.\n\t- 함수명 위에 주석을 달고 해당 내용을 붙여넣는다.\n\t- 코파일럿과 함께 페어 코딩 + 해당 함수를 좀 더 다듬는다.\n\t- 인수조건과 해당 함수를 바탕으로 chatgpt에게 테스트 케이스를 짜달라고 요청한다 + 분명히 놓치는 부분이 있기 때문에, 자세히 확인해 보면서 좀 더 다듬는다.\n\n### 관련 도구\n- [DeepL](https://www.deepl.com/translator)\n\t- chatgpt는 영어로 질문했을 때 성능이 더 좋다. 지금까지 써본것 중에 가장 좋은 번역 AI. 크롬 확장프로그램도 존재한다.\n"},{"fields":{"slug":"/posts/tip/shortcut/","title":"내가 써먹으려고 정리한 단축키 & 명령어 모음"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 내가 써먹으려고 정리한 단축키 & 명령어 모음\ndate: 2022-06-16\nupdated: 2024-03-17T15:03:20+09:00\ntags:\n  - 단축키\n  - tip\ncreated: 2022-11-17T22:40:14+09:00\n---\n\n> 아래 단축키는 mac os기준으로 작성되었습니다.\n\n## vscode\n- [공식사이트](https://code.visualstudio.com/docs/getstarted/keybindings#_basic-editing)\n\n|작업|단축키|\n|---|----|\n|콘솔 열기|`cmd` `shift` `P`|\n|터미널 열기|`alt` `ctrl` `T`|\n|수직으로 창 분할|`cmd` `L` + `<-`|\n|다른 폴더 목록보기|`cmd` `R`|\n|특정 라인만 커밋 스테이지에 올리기| 1. stage하려는 범위를 드래그한다. <br/>2. `command + k`  + `option + command + s`|\n|키보드 입력 내용 노출하기|1. 콘솔연 후 `>screen` <br/>2. 개발자 스크린캐스크 모드 토글 선택|\n|사용하지 되지않는 import 지우기|`option` `shift` `O`|\n|터미널 영역에서 탭 이동하기 - 이전탭으로|`command` `shift` `[`|\n|터미널 영역에서 탭 이동하기 - 다음탭으로|`command` `shift` `]`|\n|포커스 이동하기|`ctrl` `+`, `-`|\n|탐색기에 focus|`cmd` + `shift` + `e`|\n|함수 변수 사용처 찾거나, 정의 찾기|`f12`|\n|파일 내에서 심볼 찾기|`cmd` + `shift` + `o`|\n|프로젝트 내에서 심볼 찾기|`cmd` + `t`|\n\n## webstorm\n|작업|단축키|\n|---|----|\n|커맨드 창 열기|`shift` + `shift`|\n|패널 닫기|`shift` + `esc`|\n|go to definition|`option` + `space`|\n|cli에서 명령어 실행하기| `ctrl` + `ctrl`|\n|값이 사용되는곳 찾기(find 패널)|`option` + `f7`|\n|find 패널로 돌아가기|`cmd` + `3`|\n|한 줄씩 옮기기|`shift` + `option` + `방향키`|\n|코드 블록단위로 옮기기|`shift` + `cmd` + `방향키`|\n|한 줄 지우기|`cmd` + `enter`|\n|변경 사항 확인|`cmd` + `9`|\n|변경 사항 상세 확인|`cmd` + `d`|\n|터미널 열기|`option` + `f12`|\n|파일의 시작|`cmd` + `home`|\n|파일의 끝|`cmd` + `end`|\n|navigation으로|`cmd` + `위 방항키`|\n|webstorm 터미널에서 열기 ([참고](https://stackoverflow.com/questions/26879172/how-to-open-webstorm-from-terminal))|`webstorm .`|\n|최근 수정 파일 표시|`cmd` + `shift` + `e`|\n|최근 수정 열었던 파일 표시|`cmd` + `e`|\n|hint 보기 (노란전구)|`option` + `enter`|\n|테스트 파일에서 모든 테스트 실행|`ctrl` + `shift` + `r`|\n|테스트 파일에서 단일 테스트 실행|`ctrl` + `shift` + `d`|\n|커서 위치 이동하기| `cmd` + `shift` + `[` or `]`|\n|사용하지 않는 import 지우기| `ctrl` + `alt` + `o`|\n|전체 찾아 바꾸기| `cmd` + `shift` + `r`|\n|css 파일에서 셀렉ㅌ 찾기| `cmd` + `f12`|\n|현재파일 ~에서 보기 (ex. Project viewer)| `alt` + `f1`|\n|버튼을 키보들 누르기| `alt` + `alt를 누르고 있을때 밑줄이 생기는 글자` <img width=\"154\" alt=\"image\" src=\"https://user-images.githubusercontent.com/35283339/163316350-91e4f2e0-80a8-4eff-88f3-c8d1f2b1997b.png\"/>|\n\n## 터미널 (쉘)\n\n|작업|단축키|\n|---|----|\n|작성한 내용 잘라내기|`ctrl` `U`|\n|잘라낸 내용 붙여넣기|`ctrl` `Y`|\n|이전에 실행한 명령어 [`history`](https://man7.org/linux/man-pages/man3/history.3.html)확인 ([`fzf`](https://github.com/junegunn/fzf) 설치추천)|`ctrl` `R`|\n|커밋메세지 수정없이 <br /> 새로운 파일 커밋에 추가하기 | `git add the_left_out_file`  <br /> `git commit --amend --no-edit` |\n\n## slack\n- [공식사이트](https://slack.com/intl/ko-kr/help/articles/201374536-Slack-%ED%82%A4%EB%B3%B4%EB%93%9C-%EB%B0%94%EB%A1%9C-%EA%B0%80%EA%B8%B0)\n\n|작업|단축키|\n|---|----|\n|`esc`를 누르면서 메세지를 하나씩 확인표시를 할 수 있다.|`cmd` `shift` `a`|\n|`esc`를 누르면서 쓰레드를 하나씩 확인표시를 할 수 있다.|`cmd` `shift` `t`|\n|메세지 내용, 발신자 이름 등으로 검색하기|`cmd` `k`|\n|이전, 다음 페이지로 이동| `cmd` + `[` or `]`|\n\n## chrome\n|작업|단축키|\n|---|----|\n|개발자도구|`cmd` `shift` `i`|\n|개발자도구 수직/수평으로 보기|`cmd` `shift` `d`|\n|열려있는 탭에서 검색|`cmd` `shift` `a`|\n|즐겨찾기|`cmd` `d`|\n\n## iterm\n|작업|단축키|\n|---|----|\n|수직분할|`cmd` `d`|\n|수평분할|`cmd` `shift` `d`|\n|최대화|`cmd` `enter`|\n\n"},{"fields":{"slug":"/posts/tip/webstorm/","title":"webstorm 사용 팁"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: webstorm 사용 팁\ndate: 2022-05-31\nupdated: 2024-03-17T15:03:20+09:00\ntags:\n  - webstorm\n  - tip\ncreated: 2024-02-27T00:33:49+09:00\n---\n## Tip\n\n### 찾아 바꿀 때 정규표현식 그룹 캡쳐 활용하기\n![[Pasted image 20240227003348.png]]\n\n### ETC\n- [인덴트가 제대로 적용되지 않을 때 해결법](https://kjwsx23.tistory.com/256)\n- 가로 너비를 넘어가는 코드 줄바꿈하여 보기\n- 방법 1. View -> Active Editor -> Use Soft Wraps\n- 방법 2. `cmd` + `,` - `use soft wraps in editor` 체크\n\n"},{"fields":{"slug":"/posts/tip/나만의 업무 습관 정리/","title":"나만의 업무 습관 정리"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 나만의 업무 습관 정리\ndate: 2024-01-18\nupdated: 2024-03-17T15:03:21+09:00\ntags:\n  - tip\ncreated: 2024-01-18T22:40:14+09:00\n---\n> 회사에서 최적화했던 나의 습관들을 기록한 문서\n\n\n### 지라\n- 나만의 대시보드 만들기\n\t- 여러 보드를 사용하는 경우 한번에 볼 수 있는 장점이 있음.\n\t- 캘린더나 차트 등을 활용해 내 업무 진척도를 알 수 있다.\n\t- 대시보드를 동료에게 공유해서 내 업무 상황을 공유할 수 있다.\n\t- JQL을 간단하게 학습하면 티켓을 필터링할 때 도움이 된다.\n- automation 활용하기\n\t- 수동으로 하는 작업들을 자동화 해놓으면 나도 좋고 동료도 편하다.\n### 슬랙\n- 불필요한 알림은 음소거 처리한다.\n\t- 쓰레드의 메뉴를 클릭해서 음소거를 하기도 한다.\n- 최대한 단축키를 사용한다.\n- 당장 인지해야할, 행동해야할 쓰레드가 아니면 a를 눌러 저장하거나, 리마인드 알림 시간을 지정해놓는다. 그리고 여유로울 때 확인한다.\n- 환경설정\n\t- 홈 - 표시 - 읽지않은 멘션만\n\t- 정렬 - 알파벳순\n- 검색\n\t- 누구와 대화했던것, 대화 주제는 생각나는데 쓰레드를 못찾겠을 때\n\t\t- `with:@닉네임` 으로 검색한다.\n\n### 깃허브\n- 코드 검색\n\t- https://github.com/search?q=javascript\n\t- 특정 organization하위 검색도 가능하다 (회사코드)\n\t\t- https://github.com/search?q=org%3A{{organization이름}}+const&type=code\n\n\n### 컨플루언스\n- 동료의 스페이스를 구독해놓는다. 본인의 스페이스에 좋은 글을 작성하시는 분이 종종 계신다.\n- 회의때 문서작성을 적극적으로 참여한다. 자연스럽게 대화를 최대한 이해하려고 집중하게되는 효과가 있다.\n\n### 생활\n- 집중이 안될 때, 도저히 문제가 풀리지 않을 땐 신체를 움직인다. 계단을 걷거나 밖을 걷거나 체력단련실에서 힘을 쓰거나 폼롤러로 스트레칭을 한다.\n- 안풀리는 문제를 혼자만의 힘으로 해결하려고 끙끙 앓지말것. 주위 동료들에게 내가 알고 있는 부분과 뭘 모르는지 정리해가서 질문을 하면 생각보다 해결이 금방된다. (질문을 하면서 내 스스로 답을 찾는 경우도 은근 잦다)\n- 나만 알고 있으면 아까운 정보들은 동료들에게 퍼뜨릴 것. 그런 정보들만 올리는 슬랙 채널을 만드는 것도 좋다. 나중에 찾기도 편하고 새로운 동료에게 공유할 때도 단순히 쓰레드를 공유해주면 된다. \n"},{"fields":{"slug":"/posts/tip/레거시를 더 나은 환경으로 만들기/","title":"레거시를 더 나은 환경으로 만들기"},"frontmatter":{"draft":false},"rawBody":"---\ncreated: 2024-02-11T20:08:07+09:00\nupdated: 2024-02-17T13:51:09+09:00\ntags:\n  - 개선\n---\n> 더 나은 환경을 위한 몸부림\n\n\n### jest -> @swc/jest\n- 환경\n\t- 22년쯤 create react app로 생성된 프로젝트\n- ts -> js 트랜스파일링을 swc/jest를 통해 빠르게 진행하는 것 만으로도 시간을 많이 아낄 수 있었다.\n\t- 적용 전\n\t\t- 2~3분\n\t- 적용 후\n\t\t- 23.596초\n#### 순서\n- jest.config.js 설정을 바꿔준다.\n\t- ts-jest -> @swc/jest로 바꾸고 설정도 같이 수정\n\t- jest.setup.js -> ts파일 확장자로 변경\n\t\t- [throws spurious error on test files: @testing-library/react' should be listed in the project's dependencies, not devDependencies. · Issue #2376 · airbnb/javascript · GitHub](https://github.com/airbnb/javascript/issues/2376)\n- create-react-app 에 적용하기\n\t- config 파일을 생성하고 설정한다.\n\t- 기존에 scripts에  react-scripts로 실행하던걸 jest로 변경한다.\n\t\t- `--passWithNoTests` 로 테스트 파일이 없을 때도 통과하도록 수정한다.\n- 관련링크\n\t- [\"Must use import to load ES Module\" error within a CommonJS project when using pure ESM dependencies · Issue #102 · swc-project/jest · GitHub](https://github.com/swc-project/jest/issues/102)\n\t- [@swc-node/jest ReferenceError: React is not defined · Issue #635 · swc-project/swc-node · GitHub](https://github.com/swc-project/swc-node/issues/635)\n\t- [jsx runtime with @swc/jest · Issue #70 · swc-project/jest · GitHub](https://github.com/swc-project/jest/issues/70)\n\t- [@swc/jest incompatible with arrays in .swcrc · Issue #115 · swc-project/jest · GitHub](https://github.com/swc-project/jest/issues/115)\n\t- [Configuring SWC – SWC](https://swc.rs/docs/configuration/swcrc)\n\t- [Decorators on methods in object literals · Issue #3062 · swc-project/swc · GitHub](https://github.com/swc-project/swc/issues/3062)\n\t- [@swc/jest – SWC](https://swc.rs/docs/usage/jest)\n\t- [Unit test runs very slow (6 sec per a test) · Issue #259 · kulshekhar/ts-jest · GitHub](https://github.com/kulshekhar/ts-jest/issues/259)\n\n### CRA에서 vite로 마이그레이션\nvite로 된 프로젝트를 수정하다가 CRA로 된 프로젝트 수정하니까 속 터져서 시도하게됨. 처음에는 프로젝트를 그대로 둔채로 vite 설치 후 환경설정하려 했는데 실패함. 그냥 폴더를 하나 새로 만든 다음, 파일을 옮기는게 훨씬 쉽다.\n\n#### 순서\n- 패키지 추가\n\t- `pnpm create package vite-admin`\n- vite 새로 만들기\n\t- ` pnpm create vite new-admin --template react-ts`\n- `process.env`를 `import.meta.env`로 변경하기\n- `REACT_APP_`를 `VITE_`로 변경하기\n- 엔트리 포인트 변경하기\n\t- index.tsx -> main.ts\n- 파비콘 변경\n- 배포 파이프 라인 수정\n\t- 개발서버, 운영서버에 해당하는 코드를 잘 수정하자.\n\t- 랠릿의 경우 개발서버에 배포하고 싶으면 `env.MODE` 를 `deploy`로 강제 설정해주면된다. (근데 이러면 PR 생성해도 배포됨)\n\t- 소스맵을 업로드 중이라면 소스맵의 생성 위치 파악 필요\n- monorepo를 사용중이라면, workspace를 먼저 물리적으로 삭제하지말고 `pnpm remove {{워크스페이스 명}}`으로 지울 것\n- baseUrl 설정\n\t- 현재 배포 환경에 맞춰 baseUrl을 설정해주지 않으면 js, css 에셋 파일을 로드할 때 예상하지 못한 경로로 파일을 불러오게 됨.\n\n프로젝트 실행시간 뿐만 아니라, 빌드시간도 줄어들어서 배포시간도 같이 줄어들었다."},{"fields":{"slug":"/posts/tip/키보드 안쓰기/","title":"키보드 안쓰기"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 키보드 안쓰기\ndate: 2024-01-16\nupdated: 2024-01-16T23:57:57+09:00\ntags:\n  - tip\ncreated: 2024-01-16T22:40:14+09:00\n---\n\n#### 해머스푼\n\nlua라는 언어로 스크립트를 작성하여 단축키로 매핑하여 스크립트 실행할 수 있게 해주는 도구. 특정 url을 크롬으로 바로 킨다거나, 특정 프로그램을 연다거나 하는 것이 가능함.\n- 관련 링크\n    - [https://hannut91.github.io/blogs/hammerspoon/input-output-device](https://hannut91.github.io/blogs/hammerspoon/input-output-device)\n    - [https://johngrib.github.io/wiki/hammerspoon-inputsource-aurora/](https://johngrib.github.io/wiki/hammerspoon-inputsource-aurora/)\n        - 한글/영어일 때 화면 어딘가에 표시해주기\n\n\n#### 브라우저 안\n- [https://chromewebstore.google.com/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?pli=1](https://chromewebstore.google.com/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?pli=1)\n    - clickable한 엘리먼트에 단축키를 매핑해주는 도구\n- 단축키\n    - cmd + l : 주소창으로 이동\n    - cmd + shift + a : 탭 검색하기 + 최근에 접속한 링크 검색하기\n    - cmd + shift + m : 개발자도구에서 모바일모드 토글하기\n- 탭 관리 확장프로그램\n    - 북마크하기엔 일시적인 탭 저장 용\n- [locator](https://github.com/infi-pc/locatorjs)\n    - 로컬 개발시 컴포넌트 클릭하면 IDE 코드로 이동\n\n\n#### 브라우저 밖\n\n- [homerow](https://www.homerow.app/)\n    - vimium을 운영체제 레벨에서 사용할 수 있게 해주는데, 더 진화된 느낌\n- [AltTab](https://alt-tab-macos.netlify.app/)\n    - 윈도우에서 alt + tab쓰는 느낌을 맥에서도 구현\n\n\n#### 터미널 관련\n\n- 터미널에서 쓰는 도구 추천\n    - [fzf](https://github.com/junegunn/fzf)\n    - [lazygit](https://github.com/jesseduffield/lazygit)\n- 유용한 명령어\n    - ctrl + r : 명령어 히스토리 보기 (fzf이랑 같이쓰면 더 좋음)\n    - pbcopy, pbpaste : 클립보드에 복사하기, 터미널에 붙여넣기\n        - 특정 파일 내용을 클립보드에 복사하기: cat packages.json | pbcopy\n            - 1) cat으로 파일 내용을 터미널에 출력하고 클립보드에 2)복사한다.\n\n\n## 기타 사소한 팁\n\n- 슬랙\n    - 메시지 확인\n        - cmd + shift + a\n            - 쓰레드로 작성된 메시지를 제외한 모든 메시지 확인하기\n            - exit키로 1개 채널마다 읽음 처리 가능 or shift + exit로 한번에 처리\n    - 쓰레드 누르고 + a\n        - 나중에 보기에 등록하기\n    - 나중에 보기 목록 단축키: ctrl + 4\n    - 댓글에 대한 알림 끄기\n        - 불필요한 쓰레드인 경우 바로바로 알림꺼서 우측상단에 뜨는 알림 오지 않게 하기\n        - 특정 시간을 정해놓고 맥의 집중모드를 키는 것도 좋습니다.\n    - 검색\n        - 구글과 비슷하게 \" \" , - 등 사용가능함\n        - \" \" : 띄어쓰기 있어도 정확하게 일치 검색\n        - -: 단어 필터\n"},{"fields":{"slug":"/posts/web/video player/","title":"웹에서\b영상 재생을 하기 위한 주변 지식"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: \"웹에서\\b영상 재생을 하기 위한 주변 지식\"\ndate: 2024-04-10\ntags:\n  - javascript\n  - 플레이어\ncreated: 2024-04-10T11:21:44+09:00\nupdated: 2024-04-10T11:21:44+09:00\n---\n# 영상재생\n\n# HLS (HTTP Live Streaming)\n- 장점\n    - Apple에서 개발한 프로토콜로 iOS, macOS에서 기본 지원\n    - HTTP 기반으로 CDN과 호환성이 좋음\n    - 적응형 비트레이트 스트리밍으로 네트워크 상태에 따라 화질 조절 가능\n- 단점\n    - 초기 버퍼링 시간이 길 수 있음    \n    - 라이브 스트리밍 시 지연 시간(latency)이 발생할 수 있음.m3u8, .ts\n        \n## 동작\n1. **인코딩:** HLS 은 [H.264](https://www.cloudflare.com/learning/video/what-is-h264-avc/ \"https://www.cloudflare.com/learning/video/what-is-h264-avc/\")나 H.265 인코딩을 사용해야 합니다.\n    1. 왜? 비디오 데이터의 포맷을 다시 설정하여 모든 장치가 데이터를 인식하고 해석할 수 있게 합니다.\n2. **조각화:** 비디오는 몇 초 길이로 조각낸다 → 세그먼트. 세그먼트 길이는 다양하지만 기본 길이는 6초\n    - 비디오를 세그먼트로 나누는 것과 더불어 HLS는 비디오 세그먼트의 인덱스 파일을 만들어 세그먼트의 순서를 기록합니다.        \n    - HLS는 또한 480p, 720p, 1080p 등의 다양한 품질로 여러 세트의 세그먼트를 복제합니다\n    - 조각난 파일은 `.ts` 확장자로 저장되고 불러옴\n[참고](https://www.cloudflare.com/ko-kr/learning/video/what-is-http-live-streaming/ \"https://www.cloudflare.com/ko-kr/learning/video/what-is-http-live-streaming/\")\n\n# DASH (Dynamic Adaptive Streaming over HTTP)\n- 장점\n    - MPEG에서 개발한 개방형 표준 프로토콜\n    - 적응형 비트레이트 스트리밍으로 최적의 화질 제공\n- 단점\n    - 인코딩 및 패키징 과정이 복잡함\n    - 브라우저별로 지원 여부가 다를 수 있음\n        \n\n## 동작\n\n_HLS랑 동일하게 미디어 파일을 조각내서 저장_\n- **인코딩 및 조각화:** 원본 서버가 비디오 파일을 몇 초 길이의 세그먼트로 나눕니다. 서버는 비디오 세그먼트에 대한 목차와 유사한 색인 파일도 생성합니다. 그런 다음 세그먼트를 인코딩하는데, 이는 다양한 장치가 해석할 수 있는 형식으로 변경된다는 말입니다. MPEG-DASH에서는 어떠한 인코딩 표준도 사용할 수 있습니다.\n- **전송:** 사용자가 스트림을 보기 시작하면 인코딩된 비디오 세그먼트가 인터넷을 통해 클라이언트 장치로 푸시됩니다. 거의 모든 경우에 [콘텐츠 전송 네트워크 (CDN)](https://www.cloudflare.com/learning/cdn/what-is-a-cdn/ \"https://www.cloudflare.com/learning/cdn/what-is-a-cdn/\")는 스트림을 보다 효율적으로 배포하는 데 도움이 됩니다.\n- **디코딩 및 재생:** 사용자 장치가 스트리밍된 데이터를 수신하면 데이터를 디코딩하고 비디오를 재생합니다. 비디오 플레이어는 네트워크 조건에 적응하기 위해 품질 수준을 자동으로 전환합니다. 예를 들어 사용자의 대역폭이 작다면 비디오는 대역폭을 적게 사용하는 낮은 품질 수준에서 재생됩니다.\n[링크](https://www.cloudflare.com/ko-kr/learning/video/what-is-mpeg-dash/ \"https://www.cloudflare.com/ko-kr/learning/video/what-is-mpeg-dash/\")\n\n# .m3u8\n- HLS에서 사용되는 재생 목록(playlist) 파일 포맷\n- 비디오 **세그먼트** 정보와 URL을 포함하여 플레이어가 순차적으로 재생할 수 있도록 함\n`세그먼트는 분할, 구간, 세부부분, 쪼개는 것 이라는 뜻을 가지고 있습니다`\n\n# 세그먼트 파일 포맷\n\n## .ts (MPEG-2 Transport Stream)\n\n1. 개념\n    - HLS에서 사용되는 비디오/오디오 세그먼트 파일 포맷\n    - MPEG-2 TS 컨테이너에 인코딩된 비디오와 오디오를 포함\n2. 장점\n    - 방송 및 스트리밍에 최적화된 포맷\n    - 다중 프로그램 전송 및 DRM 적용 가능\n3. 단점\n    - 파일 크기가 상대적으로 큼\n        \n\n## fMP4 (Fragmented MP4)\n- DASH에서 주로 사용되는 세그먼트 파일 포맷\n- MP4 컨테이너를 기반으로 하며, 파일 단위로 분할되어 전송\n## WebM\n- Google에서 개발한 개방형 미디어 파일 포맷\n- VP8, VP9 비디오 코덱과 Vorbis, Opus 오디오 코덱 지원\n\n# 저작권 보호\n\n## HLS Encryption\n- 개념\n    - HLS에서 제공하는 콘텐츠 보호 메커니즘\n    - AES-128 암호화를 사용하여 미디어 _세그먼트_를 암호화\n    - 키 교환 과정을 통해 인증된 사용자만 복호화하여 재생 가능 ← 암호화 수단\n- 장점\n    - 대부분의 디바이스와 플레이어에서 지원\n    - 키 교환 과정이 비교적 간단하여 구현이 용이    \n- 단점\n    - 키 관리 및 교환 과정에서 취약점 발생 가능    \n        - 즉, 키 관리 방법을 뚫리게 되면 컨텐츠가 위험해진다.\n    - 녹화가 되기에 높은 수준의 보안이 요구되는 콘텐츠에는 부적합할 수 있음\n\n## DRM\n- 개념\n    - 디지털 콘텐츠의 불법 복제 및 유통을 방지하기 위한 기술\n    - 암호화 ↔︎ 라이선스 관리 ↔︎ 사용자 인증 등을 통해 콘텐츠 보호\n    - 각 DRM 솔루션마다 고유한 암호화 및 라이선스 관리 방식 사용    \n- 장점\n    - 제일 강력한 컨텐츠 보호 기능\n    - 다양한 비즈니스 모델(구독, 대여, 구매 등) 지원\n- 단점\n    - DRM 솔루션 간 호환성 문제 발생 가능\n    - 구현 및 유지보수 _비용 증가_\n- DRM 솔루션 종류\n    - fairplay\n    - widevine\n    - playready\n        \n\n### FairPlay\n- Apple의 DRM 솔루션\n- HLS와 함께 사용되며, iOS와 macOS에서 기본 지원\n- 서버와 클라이언트 간 인증서 기반 키 교환 방식 사용\n\n### Widevine\n- Google의 DRM 솔루션\n- DASH와 함께 사용되며, Android와 Chrome에서 기본 지원"},{"fields":{"slug":"/posts/books/object/오브젝트-00/","title":"오브젝트-00"},"frontmatter":{"draft":false},"rawBody":"[[오브젝트-01]]\n[[오브젝트-02]]\n[[오브젝트-03]]\n[[오브젝트-04]]\n[[오브젝트-05]]\n[[오브젝트-06]]"},{"fields":{"slug":"/posts/books/object/오브젝트-01/","title":"오트젝트 01 객체, 설계"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 오트젝트 01 객체, 설계\ndate: 2022-06-09\nupdated: 2022-06-09\ntags:\n  - 오브젝트\n---\n\n> [오브젝트: 코드로 이해하는 객체지향 설계] 를 읽고 정리한 내용입니다.\n\n# 객체, 설계\n\n\n> 한 가지 염두에 둬야 할 점은 이 책에서 제시하는 방법이 객체지향을 구현하기 위한 유일한 방법은 아니라는 점입니다.\n\n> 이 책은 코드를 개발하는 우리가 객체지향 패러다임이라는 용어를 사용할 때 완벽하게 동일하지는 않더라도 어느 정도 유사한 그림을 머릿속에 그릴 수 있는 기반을 제공할 것이다.\n\n> 간단히 말해 프로그래밍 패러다임은 혁명적이 아니라 발전적이다. 이런 사실은 비록 객체지향 패러다임을 주로 사용한다고 하더라도 다른 패러다임을 배우는 것이 도움 될 것이라는 사실을 암시한다.\n\n객체지향이 무조건 답은 아님. 이라는 걸 말해주려는 것 같다. 문제를 해결 할 때 접근하는 방식은 다양하고, 모든 곳에 들어 맞는 정답은 없다.\n\n\n## 티켓 판매 애플리케이션 구현하기\n\n[코드로 보기](https://github.com/padawanR0k/wiki/pull/3)\n\n> 이것은 객체 사이의 의존성과 관련된 문제이다.\n> ...\n> 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체로 인해 함께 변경될 수 있다는 사실이 내포되어 있다.\n\n- 예시: 초기 [`Theater` 클래스](https://github.com/padawanR0k/wiki/pull/3/commits/30413bd873eaec6028b24ad751ff1c3dd762bfca)\n  - 불필요한 의존성이 많이 존재한다. == 객체 사이에 결합도가 높다.\n  - 결합도가 높으면 함께 변경될 확률도 높아진다. == 유지보수가 어려워진다.\n- 개선방법\n  - `Theater`가 `Audience`와 `TicketSeller`에 내부 정보를 알지 못하도록 정보를 차단한다. -> 서로를 자율적인 존재로 만든다.\n  - `Theater`에서 가지고 있던 `enter`메소드의 [상세 로직을 캡슐화](https://github.com/padawanR0k/wiki/pull/3/commits/b01c2bccfd8d0ecde33a2dadf2c3f28a55a872b6)한다.\n  - `Theater`내부 로직을 `Audience`와 `TicketSeller`에 캡슐화하여 분리함 == 책임을 이동시킴\n    - 자율성이 높아졌고, 각 객체들이 밀접하게 연관된 작업만 하게됨 -> 응집도가 높아짐\n    - 특정 로직을 수정할 때 함께 변경해야할 코드가 줄어듬\n\n## 자율성과 결합도\n- 각 객체의 자율성을 높여도 전체 설계관점에서 보면 결합도가 상승한다.\n- 어떤 기능을 설계하는 방법은 여러가지일 수 있다\n- 결국 설계는 트레이드 오프의 산물이다. 모두를 만족하는 설계는 불가능하다.\n\n\n## 의인화\n레베카 워프스브록은 무생물인 `Bag`같은 클래스도 능동적이고 자율적인 존재로 다루며 소프트웨어 객체를 설계하는 원칙을 의인화라고 부른다."},{"fields":{"slug":"/posts/books/object/오브젝트-03/","title":"오트젝트 03 역할, 책임, 협력"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 오트젝트 03 역할, 책임, 협력\ndate: 2022-06-19\nupdated: 2022-06-19\ntags:\n  - 오브젝트\n---\n\n> [오브젝트: 코드로 이해하는 객체지향 설계] 를 읽고 정리한 내용입니다.\n\n# 역할, 책임, 협력\n\n위 세 단어가 객체지향 패러다임의 관점에서의 핵심이다. 클래스, 상속, 지연바인딩도 중요하지만 이들은 구현 측면에 치우쳐져있다.\n\n## 협력\n> 여기서 중요한 것은 다양한 객체들이 영화 예매라는 기능을 구현하기 위해 메시지를 주고 받으면서 상호작용한다는 점이다.\n> 이처럼 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 **협력**이라고 한다.\n\n> 객체는 고립된 존재가 아니라 시스템의 기능이라는 더 큰 목표를 달성하기 위해 다른 객체와 협력하는 사회적인 존재다.\n\n- 협력할 필요없는 경우 객체로 만들 필요가 없다.\n\n<br/>\n\n> 메시지 전송(message sending)은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이다.\n\n> 객체지향은 객체를 중심에 놓는 프로그래밍 패러다임이다. 여기서 객체란 상태와 **행동을 함께 캡슐화하는 실행 단위**다\n\n> 객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.\n> 객체의 상태는 그 객체가 행동을 수행하는 데 필요한 정보가 무엇인지로 결정된다.\n> 객체는 자신의 상태를 스스로 결정하고 관리하는 자율적인 존재이기 때문에 객체가 수행하는 행동에 필요한 상태도 함께 가지고 있어야 한다.\n\n- 이 부분이 프론트엔드에 적용하기 가장 힘든 부분인거 같다.\n\n<br/>\n\n## 책임\n\n> 협력에 참여하기 위해 객체가 수행하는 행동을 책임이라고 부른다.\n\n> 즉, 객체의 책임은 객체가 무엇을 알고 있는가와 무엇을 할 수 있는가로 구성된다.\n> 크레이그 라만(Craig Larman)은 이러한 분류 체계에 따라 객체의 책임을 크게 하는 것(doing)과 아는 것(knowing)의 두 가지 범주로 나누어 세분화하고 있다.\n\n- 하는 것\n\t- `Movie`가 예매 가격을 계산할 책임을 지는 것\n- 아는 것\n\t- `Screening`이 자신이 상영할 영화를 알고 있어야하는 것\n\n> 여기서 중요한 사실은 책임의 관점에서 아는 것과 하는 것이 밀접하게 연관돼 있다는 점이다.\n> 객체는 자신이 맡은 책임을 수행하는 데 필요한 정보를 알고 있을 책임이 있다.\n> 또한 객체는 자신이 할 수 없는 작업을 도와줄 객체를 알고 있을 책임이 있다\n\n> 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것이다.\n> 이를 책임 할당을 위한 INFORMATION EXPERT(정보 전문가) 패턴이라고 부른다.\n\n- 여기서 정보 전문가는 책임해결을 위헤 필요한 정보를 가지고 있는 객체\n\n<br/>\n\n> 객체지향 설계는 시스템의 책임을 완료하는 데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰간다.\n\n- 객체지향 설계는 프랙탈적인 성향을 띈다.\n\n<br/>\n\n> 메시지를 선택했으면 메시지를 처리할 적절한 객체를 선택해야 한다.\n\n> 어떤 경우에는 응집도와 결합도의 관점에서 정보 전문가가 아닌 다른 객체에게 책임을 할당하는 것이 더 적절한 경우도 있다.\n> 하지만 기본적인 전략은 책임을 수행할 정보 전문가를 찾는 것이다.\n> 정보 전문가에게 책임을 할당하는 것만으로도 상태와 행동을 함께 가지는 자율적인 객체를 만들 가능성이 높아지기 때문이다.\n\n> 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 책임 주도 설계라고 부른다.\n\n> 다시 말해 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 했다\n\n- 여러번 나오지만 메시지를 중점으로 생각하는것이 중요하다.\n\n<br/>\n\n\n> 객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수는 객체의 행동이 아니라 상태에 초점을 맞추는 것이다.\n> 초보자들은 먼저 객체에 필요한 상태가 무엇인지를 결정하고, 그 후에 상태에 필요한 행동을 결정한다.\n> 이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다.\n\n\n## 역할\n\n> 이처럼 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 역할이라고 부른다.\n\n- 가장이라는 역할은 가족을 보살피고, 의식주를 책임져야한다. 가장은 아버지가 아니더라도 수행할 수 있는 역할이다.\n\n<br />\n\n> 역할이라는 개념을 고려하지 않고 객체에게 책임을 할당한다고 가정해보자\n\n\n> 연극 안에서 배역을 연기하는 배우라는 은유는 협력 안에서 역할을 수행하는 객체라는 관점이 가진 입체적인 측면들을 훌륭하게 담아낸다.\n> 협력은 연극과 동일하고 코드는 극본과 동일하다. 배우는 연극이 상영될 때 배역이라는 특정한 역할을 연기한다.\n> 객체는 협력이라는 실행 문맥 안에서 특정한 역할을 수행한다. 연극 배우는 연극이 끝나면 자신의 배역을 잊고 원래의 자기 자신을 되찾는다.\n>  객체는 협력이 끝나고 협력에서의 역할을 잊고 원래의 객체로 돌아올 수 있다.\n\n\n- 가장이 해야할 일을 가족의 구성원들이 흩어져서 맡게된다고 생각해보자.\n\n> 순수하게 책임의 관점에서 두 협력을 바라보면 AmountDiscountPolicy와 PercentDiscountPolicy 모두 할인 요금 계산이라는 동일한 책임을 수행한다는 사실을 알 수 있다.\n> 따라서 객체라는 존재를 지우고 할인 요금을 계산하라라는 메시지에 응답할 수 있는 대표자를 생각한다면 두 협력을 하나로 통합할 수 있을 것이다.\n> 이 대표자를 협력 안에서 두 종류의 객체를 교대로 바꿔 끼울 수 있는 일종의 슬롯으로 생각할 수 있다. 이 **슬롯**이 바로 역할이다.\n\n- 슈퍼페미콤에 끼우던 [**슬롯**](https://www.google.com/search?q=%EC%8A%88%ED%8D%BC%ED%8C%A8%EB%AF%B8%EC%BD%A4+%EC%8A%AC%EB%A1%AF&rlz=1C5CHFA_enKR880KR880&sxsrf=ALiCzsbnJUafp18qpUABWBR6hfwwQAloEQ:1655624853455&source=lnms&tbm=isch&sa=X&ved=2ahUKEwi-y5Wag7n4AhUcJqYKHY1bDkYQ_AUoAXoECAEQAw&biw=1536&bih=849&dpr=2)을 생각해보자\n\n> 인터페이스 업캐스팅, 다형성, 늦은 바인딩, 상속, 컴파일 시간 의존성과 실행 시간 의존성의 차이와 같은 다양한 기술적 메커니즘이 숨겨져 있다.\n> 하지만 여기서 중요한 것은 이러한 기술적 메커니즘들이 모여 유연하고 재사용 가능한 협력을 만들 수 있는 기반을 제공한다는 것이다.\n\n> 협력에 참여하는 후보가 여러 종류의 객체에 의해 수행될 필요가 있다면 그 후보는 역할이 되지만 단지 한 종류의 객체만이 협력에 참여할 필요가 있다면 후보는 객체가 된다.\n\n- 솔직히 잘 이해가 안되는 부분이다..\n\n<br/>\n\n> 처음에 특정 시나리오에 대한 협력을 구상할 때는 아마도 도메인 모델에 있는 개념들을 후보로 선택해 직접 책임을 할당할 것이다.\n> 다양한 시나리오를 설계로 옮기면서 협력을 지속적으로 정제하다 보면 두 협력이 거의 유사한 구조를 보인다는 것을 발견하게 될 것이다.\n> 이 경우 두 협력을 하나로 합치면서 두 객체를 포괄할 수 있는 역할을 고려해서 객체를 역할로 대체할 수 있다.\n\n> 첫 번째 장점은 추상화 계층만을 이용하면 중요한 정책을 상위 수준에서 단순화할 수 있다는 것이다. 두 번째 장점은 설계가 좀 더 유연해진다는 것이다.\n\n- 상위수준에서 단순화되면 사용하는 입장에서 더 편하다. == 적은 정보만 알면된다.\n- 설계가 유연해지면 서비스를 유지보수하기 편해진다.\n\n> 따라서 객체는 다양한 역할을 가질 수 있다. 객체는 여러 역할을 가질 수 있지만 특정한 협력 안에서는 일시적으로 오직 하나의 역할만이 보여진다는 점에 주의하라.\n> 이것은 배우가 하나의 연극에서 오직 하나의 배역을 연기하는 것과 동일하다.\n> 객체가 다른 협력에 참여할 때는 이전의 역할은 잊혀지고 해당 협력에서 바라보는 역할의 측면에서 보여질 것이다\n"},{"fields":{"slug":"/posts/books/object/오브젝트-04/","title":"오트젝트 04 설계 품질과 트레이드 오프"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 오트젝트 04 설계 품질과 트레이드 오프\ndate: 2022-06-17\nupdated: 2022-06-17\ntags:\n  - 오브젝트\n---\n\n> [오브젝트: 코드로 이해하는 객체지향 설계] 를 읽고 정리한 내용입니다.\n\n\n객체지향에서 올바른 설계는 올바른 객체에게 올바른 역할을 부여해야한다. 이 때 응집도와 결합도를 적절하게 저울질하면서 코드를 작성해야한다.\n\n> 결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙이 있다. 객체의 상태가 아니라 객체의 행동에 초점을 맞추는 것이다.\n\n\n## 데이터 중심 설계\n\n> 데이터 중심의 설계에서는 객체가 포함해야 하는 데이터에 집중한다\n\n> 특히 Movie 클래스의 경우처럼 객체의 종류를 저장하는 인스턴스 변수(movieType)와 인스턴스의 종류에 따라 배타적으로 사용될 인스턴스 변수(discountAmount, discountPercent)를 하나의 클래스 안에 함께 포함시키는 방식은 데이터 중심의 설계 안에서 흔히 볼 수 있는 패턴이다.\n\n- 데이터를 모아놓고 이들을 쉽게 오염시키 못하게 하려면 접근자와 수정자를 추가하면 된다. 자바스크립트에서는 get, set 키워드를 지원하고 추후에는 `#` private 키워드도 추가될 예정이다.\n\n\n## 설계 트레이드 오프\n\n### 캡슐화\n\n> 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서다. 여기서 구현이란 나중에 변경될 가능성이 높은 어떤 것을 가리킨다. 객체지향이 강력한 이유는 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 적절하게 조절할 수 있는 장치를 제공하기 때문이다.\n\n- 인터페이스는 구현과 반대로 변경이 적어야하기 때문에 안정적이다.\n\n\n> 설계가 필요한 이유는 요구사항이 변경되기 때문이고, 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문이다. 따라서 변경의 관점에서 설계의 품질을 판단하기 위해 캡슐화를 기준으로 삼을 수 있다.\n\n### 응집도와 결합도\n\n> 객체지향의 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.\n\n> 객체지향의 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다.\n\n- 현실세계에서도 그렇듯 어떤 객체가 알맞지 않은 책임을 가지거나, 부적절한 관계를 유지하고 있으면 문제가 발생하기 마련이다.\n\n\n\n\n> 응집도가 높을수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다. 변경으로 인해 수정되는 부분을 파악하기 위해 코드 구석구석을 헤매고 다니거나 여러 모듈을 동시에 수정할 필요가 없으며 변경을 반영하기 위해 오직 하나의 모듈만 수정하면 된다.\n\n- 응집도가 높은 아주 중요한 코드가 있을 때, 만약 이게 깨지게 된다면 큰 타격이 있기 때문에 응집도가 높으면서 서비스 코어로직인 경우에는 테스트 코드를 꼭 짜야할 것이다.\n\n\n> 결합도 역시 변경의 관점에서 설명할 수 있다. 결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있다.\n\n> 내부 구현을 변경했을 때 이것이 다른 모듈에 영향을 미치는 경우에는 두 모듈 사이의 결합도가 높다고 표현한다. 반면 퍼블릭 인터페이스를 수정했을 때만 다른 모듈에 영향을 미치는 경우에는 결합도가 낮다고 표현한다\n\n> 캡슐화를 지키면 모듈 안의 응집도는 높아지고 모듈 사이의 결합도는 낮아진다. 캡슐화를 위반하면 모듈 안의 응집도는 낮아지고 모듈 사이의 결합도는 높아진다. 따라서 응집도와 결합도를 고려하기 전에 먼저 캡슐화를 향상시키기 위해 노력하라.\n\n## 데이터 중심의 영화 예매 시스템의 문제점\n\n### 캡슐화 위반\n\n> 접근자와 수정자에 과도하게 의존하는 설계방식을 추측에 의한 설계 전략이라고 부른다.\n\n- 객체간의 협력을 먼저 생각하지 않으면, 내부상태를 드러내느 코드를 짜게 된다.\n\n\n> 객체 내부의 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것을 의미한다. 그리고 더 나쁜 소식은 단지 객체의 내부 구현을 변경했음에도 이 인터페이스에 의존하는 모든 클라이언트들도 함께 변경해야 한다는 것이다.\n\n\n## 데이터 중심 설계의 문제점\n\n> 데이터 중심의 설계가 변경에 취약한 이유는 두 가지다.  데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다. 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.\n\n- 결국 계속 나오는 중요한 키워드는 **협력**이다.\n\n\n> 데이터 중심의 설계를 시작할 때 던졌던 첫 번째 질문은 이 객체가 포함해야 하는 데이터가 무엇인가? 다. 데이터는 구현의 일부라는 사실을 명심하라.\n\n\n> 안타깝게도 데이터 중심 설계에서 초점은 객체의 외부가 아니라 내부로 향한다. 실행 문맥에 대한 깊이 있는 고민 없이 객체가 관리할 데이터의 세부 정보를 먼저 결정한다. 객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하기 때문에 이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수밖에 없다. \n\n- 구현이 먼저 이루어지면, 협력을 하기위해 억지로 끼워맞추면서 인터페이스가 괴랄하게 변한다는걸 강조하는것 같다.\n\n\n\n-알라딘 eBook <오브젝트> (조영호 지음) 중에"},{"fields":{"slug":"/posts/books/object/오브젝트-06/","title":"오트젝트 06 메시지와 인터페이스"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 오트젝트 06 메시지와 인터페이스\ndate: 2022-07-24\nupdated: 2022-07-24\ntags:\n  - 오브젝트\n---\n\n> [오브젝트: 코드로 이해하는 객체지향 설계] 를 읽고 정리한 내용입니다.\n\n\n> 객체지향 프로그래밍에 대한 가장 흔한 오해는 애플리케이션이 클래스의 집합으로 구성된다는 것이다\n\n- 클래스가 아니더라도, 객체가 수행하는 책임에 초점을 맞춰 객체간에 메시지를 송수신하는 방식으로 코드를 작성하는 것이 객체지향 프로그래밍인듯 하다.\n\n\n\n## 협력과 메시지\n### 클라이언트-서버모델\n\n> 두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포는 클라이언트-서버(Client-Server) 모델이다. 협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라고 부른다.\n\n> 두 객체 사이의 협력을 가능하게 해주는 매개체는 바로 메시지이다.\n\n### 메시지와 메시지 전송\n\n> 메시지(message)는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다. 한 객체가 다른 객체에게 도움을 요청하는 것을 메시지 전송(message sending) 또는 메시지 패싱(message passing)이라고 부른다. 이때 메시지를 전송하는 객체를 메시지 전송자(message sender)라고 부르고 메시지를 수신하는 객체를 메시지 수신자(message receiver)라고 부른다. 클라이언트-서버 모델 관점에서는 메시지 전송자는 클라이언트, 메시지 수신자는 서버라고 부르기도 한다. 메시지는 오퍼레이션명(operation name)과 인자(argument)로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것이다. 따라서 메시지 전송은 메시지 수신자, 오퍼레이션명, 인자의 조합이다\n\n\n### 퍼블릭 인터페이스와 오퍼레이션\n\n> 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션(operation)이라고 부른다.\n\n### 시그니쳐\n> 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 시그니처(signature)라고 부른다\n\n\n## 인터페이스와 설계 품질\n\n> 디미터 법칙을 간단하게 요약하면 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다. 디미터 법칙은 낯선 자에게 말하지 말라(dont talk to strangers) 또는 오직 인접한 이웃하고만 말하라(only talk to your immediate neighbors)로 요약할 수 있다.\n\n- 되도록이면 하나의 도트만 사용하되, 필요한 부분에서는 여러개의 도트를 사용할 수도 있다.\n- 기차충돌: 여러개의 도트를 사용해 연쇄적으로 메소드를 호출하고 있는 코드.\n\n\n### 묻지 말고 시켜라\n\n> ReservationAgency는 Screening 내부의 Movie에 접근하는 대신 Screening에게 직접 요금을 계산하도록 요청했다. 요금을 계산하는 데 필요한 정보를 잘 알고 있는 Screening에게 요금을 계산할 책임을 할당한 것이다.\n> ...\n>\n> 묻지 말고 시켜라(Tell, Dont Ask)는 이런 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어다.\n\n> 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜라. 협력을 설계하고 객체가 수신할 메시지를 결정하는 매 순간 묻지 말고 시켜라 원칙과 디미터 법칙을 머릿속에 떠올리는 것은 퍼블릭 인터페이스의 품질을 향상시킬 수 있는 좋은 습관이다.\n\n\n### 의도를 드러내는 인터페이스\n> 메서드 이름을 변경한다는 것은 메시지를 전송하는 클라이언트의 코드도 함께 변경해야 한다는 것을 의미한다. 따라서 책임을 수행하는 방법을 드러내는 메서드를 사용한 설계는 변경에 취약할 수밖에 없다.\n\n> 메서드의 이름을 짓는 두 번째 방법은 어떻게가 아니라 무엇을 하는지를 드러내는 것이다\n\n> 근본적으로 디미터 법칙을 위반하는 설계는 인터페이스와 구현의 분리 원칙을 위반한다. 기억해야 할 점은 객체의 내부 구조는 구현에 해당한다는 것이다.\n\n\n>오퍼레이션의 이름은 협력이라는 문맥을 반영해야 한다. 오퍼레이션은 클라이언트가 객체에게 무엇을 원하는지를 표현해야 한다. 다시 말해 객체 자신이 아닌 클라이언트의 의도를 표현하는 이름을 가져야 한다. sellTo, buy, hold라는 이름은 클라이언트가 객체에게 무엇을 원하는지를 명확하게 표현한다. setTicket은 그렇지 않다.\n\n\n\n\n## 원칙의 함정\n> 앞에서 설명한 것처럼 디미터 법칙은 오직 하나의 도트만을 사용하라라는 말로 요약되기도 한다. 따라서 대부분의 사람들은 자바 8의 IntStream을 사용한 아래의 코드가 기차 충돌을 초래하기 때문에 디미터 법칙을 위반한다고 생각할 것이다.\n\n> 모든 상황에서 맹목적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 된다. 결과적으로 객체는 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 결과적으로 응집도가 낮아진다.\n\n- 필요한 곳과 아닌 곳을 구분할 것\n\n\n### 명령-쿼리 분리 원칙\n\n> 명령-쿼리 분리 원칙은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다.\n\n> 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈을 루틴(routine)이라고 부른다. 루틴은 다시 프로시저(procedure)와 함수(function)로 구분할 수 있다\n\n> 명령과 쿼리를 분리하기 위해서는 다음의 두 가지 규칙을 준수해야 한다.\n>\n> 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.\n\t객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.\n\n> 명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 참조 투명성(referential transparency)의 장점을 제한적이나마 누릴 수 있게 된다.?참조 투명성이라는 특성을 잘 활용하면?버그가 적고,?디버깅이 용이하며, 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작성할 수 있다.\n\n> 참조 투명성이란 어떤 표현식e가 있을 때 모든 e를 e의 값으로 바꾸더라도 결과가 달라지지 않는 특성이라는 점을 기억하라.\n\n- 약간 함수형 프로그래밍과도 연관이 있는 것 같다.\n\n\n> 컴퓨터의 세계와 수학의 세계를 나누는 가장 큰 특징은 부수효과(side effect)의 존재 유무다.?프로그램에서 부수효과를 발생시키는 두 가지 대표적인 문법은 대입문과 (원래는 프로시저라고 불려야 올바른) 함수다. 수학의 경우 x의 값을 초기화한 후에는 값을 변경하는 것이 불가능하지만 프로그램에서는 대입문을 이용해 다른 값으로 변경하는 것이 가능하다. 함수는 내부에 부수효과를 포함할 경우 동일한 인자를 전달하더라도 부수효과에 의해 그 결괏값이 매번 달라질 수 있다.\n\n"},{"fields":{"slug":"/posts/books/object/오브젝트-05/","title":"오트젝트 05 책임 할당하기"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 오트젝트 05 책임 할당하기\ndate: 2022-07-17\nupdated: 2022-07-17\ntags:\n  - 오브젝트\n---\n\n> [오브젝트: 코드로 이해하는 객체지향 설계] 를 읽고 정리한 내용입니다.\n\n\n> 책임에 초점을 맞춰서 설계할 때 직면하는 가장 큰 어려움은 어떤 객체에게 어떤 책임을 할당할지를 결정하기가 쉽지 않다는 것이다.\n책임 할당 과정은 일종의 트레이드오프 활동이다.\n동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라진다.\n따라서 올바른 책임을 할당하기 위해서는 다양한 관점에서 설계를 평가할 수 있어야 한다.\n\n\n\n\n## 책임 주도 설계를 향해\n\n> 데이터는 객체가 책임을 수행하는 데 필요한 재료를 제공할 뿐이다. 객체지향에 갓 입문한 사람들이 가장 많이 저지르는 실수가 바로 객체의 행동이 아니라 데이터에 초점을 맞추는 것이다. 너무 이른 시기에 데이터에 초점을 맞추면 객체의 캡슐화가 약화되기 때문에 낮은 응집도와 높은 결합도를 가진 객체들로 넘쳐나게 된다. 그 결과로 얻게 되는 것은 변경에 취약한 설계다.\n\n- 섣불리 예측해서 코드를 작성하지 말자.\n\n\n### 데이터보다 행동을 먼저 결정하라\n\n> 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서다. 여기서 구현이란 나중에 변경될 가능성이 높은 어떤 것을 가리킨다. 객체지향이 강력한 이유는 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 적절하게 조절할 수 있는 장치를 제공하기 때문이다.\n\n- 인터페이스는 구현과 반대로 변경이 적어야하기 때문에 안정적이다.\n\n### 협력이라는 문맥안에서 책임을 찾아라\n\n> 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다\n\n\n## 책임 할당을 위한 GRASP 패턴\n\n> 많은 사람들이 도메인 모델은 구현과는 무관하다고 생각하지만 이것은 도메인 모델의 개념을 오해한 것에 불과하다. 도메인 모델은 도메인을 개념적으로 표현한 것이지만 그 안에 포함된 개념과 관계는 구현의 기반이 돼야 한다. 이것은 도메인 모델이 구현을 염두에 두고 구조화되는 것이 바람직하다는 것을 의미한다. 반대로 코드의 구조가 도메인을 바라보는 관점을 바꾸기도 한다\n\n- 도메인과 코드의 구조는 서로 상호작용하며 서로에게 영향을 끼친다.\n\n### 높은 응집도와 낮은 결합도\n\n> 다시 말해 두 협력 패턴 중에서 높은 응집도와 낮은 결합도를 얻을 수 있는 설계가 있다면 그 설계를 선택해야 한다는 것이다.\n\n- 가장 좋은 케이스, 하지만 현실에서 이 둘은 반비례하는 경우가 많다.\n\n\n## 구현을 통한 검증\n\n> 응집도가 낮다는 것은 서로 연관성이 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐져 있다는 것을 의미한다. 따라서 낮은 응집도가 초래하는 문제를 해결하기 위해서는 변경의 이유에 따라 클래스를 분리해야 한다.\n\n> 코드를 통해 변경의 이유를 파악할 수 있는 첫 번째 방법은 인스턴스 변수가 초기화되는 시점을 살펴보는 것이다. 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다. 반면 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화하고 일부는 초기화되지 않은 상태로 남겨진다.\n\n> 따라서 함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.\n\n> 코드를 통해 변경의 이유를 파악할 수 있는 두 번째 방법은 메서드들이 인스턴스 변수를 사용하는 방식을 살펴보는 것이다. 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다. 반면 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다.\n\n- 응집도와 결합도는 다양한 곳에서 영향을 받는다. 여기서는 코드가 변경이 필요할 때 몇가지의 변경 이유가 필요한지 체크하는 것, 변수가 초기화되는 시점 등을 이야기한다.\n\n\n### 다형성을 통해 분리하기\n\n> 구현을 공유할 필요 없이 역할을 대체하는 객체들의 책임만 정의하고 싶다면 인터페이스를 사용하면 된다.\n\n> 다시 말해 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하라는 것이다. GRASP에서는 이를 POLYMORPHISM(다형성) 패턴이라고 부른다.\n\n> Movie의 관점에서 DiscountCondition의 타입이 캡슐화된다는 것은 새로운 DiscountCondition 타입을 추가하더라도 Movie가 영향을 받지 않는다는 것을 의미한다. Movie에 대한 어떤 수정도 필요 없다. 오직 DiscountCondition 인터페이스를 실체화하는 클래스를 추가하는 것으로 할인 조건의 종류를 확장할 수 있다.이처럼 변경을 캡슐화하도록 책임을 할당하는 것을 GRASP에서는 PROTECTED VARIATIONS(변경 보호) 패턴이라고 부른다.\n\n> 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화하라\n\n\n> 여기서 하고 싶은 말은 책임 주도 설계 방법에 익숙하지 않다면 일단 데이터 중심으로 구현한 후 이를 리팩터링하더라도 유사한 결과를 얻을 수 있다는 것이다. 처음부터 책임 주도 설계 방법을 따르는 것보다 동작하는 코드를 작성한 후에 리팩터링하는 것이 더 훌륭한 결과물을 낳을 수도 있다. 캡슐화, 결합도, 응집도를 이해하고 훌륭한 객체지향 원칙을 적용하기 위해 노력한다면 책임 주도 설계 방법을 단계적으로 따르지 않더라도 유연하고 깔끔한 코드를 얻을 수 있을 것이다.\n"},{"fields":{"slug":"/posts/books/object/오브젝트-02/","title":"오트젝트 02 객체지향 프로그래밍"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: 오트젝트 02 객체지향 프로그래밍\ndate: 2022-06-11\nupdated: 2022-06-11\ntags:\n  - 오브젝트\n---\n\n> [오브젝트: 코드로 이해하는 객체지향 설계] 를 읽고 정리한 내용입니다.\n\n# 객체지향 프로그래밍\n\n\n## 영화 예매 시스템\n이번 장에서는 온라인 영화 예매 시스템을 구현해본다. 먼저 영화라는 도메인에 대해서 용어에 대한 의미를 정한다.\n- `영화`\n\t- 제목, 상영 시간, 가격 정보 등 기본적인 정보\n- `상영`\n\t- 상영 일자, 시간, 순번 등\n\n다음, 요금 할인에 대한 부분을 정한다.\n- 할인 조건\n\t- 순서 조건\n\t\t- 특정 순번에 상영되는 영화는 할인한다.\n\t- 기간 조건\n\t\t- 특정 기간에 상영 시작되는 영화는 할인한다.\n- 할인 정책\n\t- 금액 할인 정책\n\t\t- 일정금액을 할인한다.\n\t- 비율 할인 정책\n\t\t- 일정금액의 비율을 할인한다.\n\n\n### 클래스를 작성할 때 하는 실수\n대부분의 사람들은 클래스를 먼저 결정한 후에 어떤 속성과 메서드가 필요한지 고민한다. 하지만 이는 객체가  무엇을 하는지에는 초점이 맞춰지 있지 않기 때문에 좋지 않은 습관이다.\n\n좋은 객체지향을 위해 집중해야하는 두가지\n- 어떤 클래스가 필요한지보다 어떤 객체들이 필요한지 고민하라\n- 객체를 독립적인 존재가아닌 협력하는 공동체의 일원으로 봐야한다. 이는 설계를 유연하고 확장 가능하게 만든다.\n\n\n\n### 도메인\n- 뜻\n\t- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야\n\t- 예시\n\t\t- 영화 예매를 쉽고 빠르게 위해 영화 예매 시스템을 사용한다.\n\n\n### 클래스 구현\n 좋은 클래스를 설계할 때 중요한 핵심은 어떤 부분을 공개(`public`)하고 어떤 부분을 감출지(`private`) 결정하는 것이다. 그 경계가 객체의 자율성을 보장하기 때문이다.\n\n### 자율적인 객체\n객체의 내부 외부를 분리하지 않으면  자율성이 떨어지고 이는 설계와 유지보수를 어렵게만든다.\n\n#### 캡슐화\n객체는 상태와 행동을 함께가지는 존재이고 스스로 판단하고 행동하는 자율적인 존재이다. 객체지향은 객체라는 단위안에 데이터와 기능을 묶어 문제를 해결하는 아이디어를 표현한다. 이처럼 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고한다.\n\n외부에서 접근 가능한 객체의 외부를 public interface 라고 부르며, 외부에서 접근할 수 없는 내부를 implementation(구현) 이라고 부른다. 이 둘의 분리는 객체지향 프로그램의 핵심 원리이다.\n\n클래스 작성자는 클래스를 사용하는 클라이언트 프로그래머가 쉽게 내부에 접근할 수 없도록 구현부를 외부에 노출하지 않는다. 이는 추후 수정이 있을 때 클라이언트 프로그래머에 가는 영향을 걱정하지 않고 수정할 수 있게 해준다. 이를 implementation hiding(구현 은닉)이라고 부른다.\n\n### 협력하는 공동체\n의미를 좀 더 명시적이고 분명하게 표현할 수 있으면, 객체를 사용해서 해당 개념을 구현하자. 간단한 변수일지라도 명시적으로 표현된 부분들은 설계의 명확성과 유연성을 높여준다.\n\n객체는 다른 객체와 공개된 인터페이스를 통해 소통한다. 이때 다른 객체에 공개된 행동을 수행하라고 하는 부분을 요청이라고하고, 요청 당한 객체가 그에 대한 답을 보내주는것을 응답이라고한다. 프론트엔드와 백엔드와 비슷하다.  서로 주고받는 내용을 메시지라고 하며, 수신된 메시지를 처리하기 위한 각 객체들의 방법을 메서드라고 부른다.\n\n\n설계가 유연해질수록 코드는 이해하기 어렵고 디버깅하기 어려지게된다. 훌륭한 객체지향을 하기 위해서는 유연성과 가독성 사이에서 고민해야한다.\n\n### 다형성\n- 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅이라고 부른다. `DiscountPoilcy` 와 `AmountDisCountPolicy`, `PercentDisCountPolicy`들의 관계\n- `Movie` 클래스는 동일한 메시지를 전송하지만, 전달받은 메시지(Policy)에 따라 내부 로직(메서드)이 돌아간다. 이를 다형성이라고 부른다.\n\t- 다형성을 구현하기 위해서는 실행되는 메서드가 결정되는 시점이 컴파일 시점이 아닌 실행 시점이여야한다. 이를 동적바인딩이라고 한다.\n\n\n### 트레이드오프\n다형성을 통해 클래스를 설계하는 경우, 코드의 일관성을 유지할 수 있다는 장점이 있지만 가독성이 떨어질 수 있다는 단점이 있다. 모든것에는 정답이 없고 트레이드 오프가 있을 뿐이다. 고민하고 트레이드 오프해야한다.\n\n### 합성\n**상속**은 객체지향에서 코드를 재활용하기 위해 널리 사용된다. 하지만 설계 관점에서는 캡슐화를 위반하고 설계를 유연하지 못하게 만든 다는 단점이 있다. 자식이 부모를 지나치게 많이 알아야하기 때문이다. 또한 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다.\n**합성**은 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법이다. 부모 클래스로써 확장하여 사용하지 않고 멤버변수로 두어 사용한다.\n\n\n\n\n"},{"fields":{"slug":"/posts/cloud/cloudflare/my-dns/","title":"github 블로그에 도메인 연결하기 by cloudflare"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: github 블로그에 도메인 연결하기 by cloudflare\ndate: 2022-11-01\nupdated: 2022-11-19T13:10:55+09:00\ntags:\n  - cloudflare\ncreated: 2022-11-19T13:10:55+09:00\n---\n\n# 계기\n기존에는 github pages를 사용해 이 위키 사이트를 [padawanR0k.github.io/wiki](padawanR0k.github.io/wiki)에 배포했었다.\n`padawanR0k.github.io`와 겹치는 부분때문에 뭔가 SEO가 잘  안되기도 했고, 예전부터 나만의 주소를 가보고 싶었어서 도메인 구매하기로 마음을 먹었다.\n\n## cloudflare domains\n구글링을 해보니 도메인을 구매할 수 있는 곳은 많았다. [godaddy](https://kr.godaddy.com/), [google domains](https://domains.google/), [가비아](https://www.gabia.com/) 등.\n그러다가 cloudflare에서도 도메인을 살 수 있다는걸 알게됐다. cloudflare는 2022 [인프콘 방명록](https://github.com/inflearn/infcon2022-guestbook)을  `Pages` 로 배포하면서 처음 써봤다. 그 때 써보면서 사용성이 편하다고 느꼈다.  나중에 한번 써먹어봐야지 했는데 딱 적당한 기회인 것 같았다.\n\n## 도메인 구매하기\n내가 사려는 도메인이 얼마인지 확인할 수 있는 페이지는 로그인 후 좌측 LNB 영역에 Domain Registration - Register Domains 메뉴를 통해 접근할 수 있다.\n결제를 하기 위해서는 해외결제가 가능한 카드가 필요하고 영문으로 주소를 입력해야한다. 영문주소는 [네이버](https://search.naver.com/search.naver?ie=UTF-8&query=%EC%98%81%EB%AC%B8%EC%A3%BC%EC%86%8C&sm=chr_hty)에서 확인가능하다.  주소 입력은 해당 [블로그](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=et119jin&logNo=221322949445)를 참고하면 좋다.\n![[address-input.png]]\n\n\n## 연동하기\n이제 해당 도메인으로 접속했을때 github pages로 배포된 곳으로 리다이렉트 시키는 작업이 필요하다.\n1. 좌측 LNB 영역에 Websites에서 `Add a Site` 버튼을 누르고 내가 구매한 도메인 입력\n2. cloudflare에 캐싱될 수 있는 레코드들이 나온다. 필요한 레코드를 활성화 시키고 `Continue` 버튼 클릭\n3. Free plan 클릭\n4. Done\n5. 방금 등록한 site의 DNS 메뉴로 이동\n6. A레코드 등록\n\t1. 내 깃허브 블로그의 아이피를 알아내 다음과 같이 입력한다 ([링크 참조](https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-a-records-with-your-dns-provider))\n\t2. ![[dns-setting.png]]\n7. github setting에서 커스텀 도메인을 등록한다 ([링크 참조](https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/verifying-your-custom-domain-for-github-pages))\n\t1. 그럼 인증을 위한 TXT 타입의 레코드를 추가하라고 안내가 나온다. 해당 레코드를 추가하고 인증을 완료하자\n8. 블로그 레포지토리 setting - Pages - Custom Domain에 구매한 도메인을 입력한다.\n\n\n## 구글한테 URL 변경을 알리자\nSEO를 위해 [Google Search Console](https://search.google.com/search-console/about)을 사용중이라면, URL이 변경됐음을 구글에 알려야한다.\n1. 서치 콘솔에 접속\n2. 새롭게 사용할 도메인으로 속성을 추가한다.\n3. 기존에 등록한 속성의 설정 - 일반 설정 - 주소 변경 클릭\n\n\n## To do list\n- Cloudflare 서비스 좀 더 활용해보기\n\t- Pages\n\t- Analytics\n- wiki에 글 자주 올리기\n- SEO 잘되는지 확인하기\n\n\n## 번외\n\n### cloudflare 사용 전/후 로드 속도 비교\n> 개발자도구 - 네트워크 탭에서 har를 다운받아 https://compare.sitespeed.io/ 에서 비교하여 볼 수 있다.\n\n#### 사용 전\n![[har-before.png]]\n\n#### 사용 후\n![[har-after.png]]\n\n1줄요약: 초기 block시간이 3732ms -> 847ms 만큼 줄었음\n\n#### cloudflare pages로 배포할 때 단점\n이 위키는 페이지의 최근 수정시간을 보여줄 수 있는 기능이 있다. 하지만 왜인지 이 부분이 항상 배포한 시각으로 고정되고 있었다.\n이 위키 테마를 먼저 사용하고 계시던 분께 [질문](https://github.com/padosum/blog/discussions/35#discussioncomment-4072910)하여 알아낸 원인은 다음과 같았다.\n1. 배포를 cloudflare pages를 사용하고 있었다.\n2. cloudflare pages는 단순히 깃허브 레포지토리만 연결하고, 빌드 명령어만 지정해주면 알아서 배포해준다.\n3. 빌드를 하기위해 레포지토리를 clone할 때, git clone시 [shallow clone](https://bitlog.tistory.com/66)을 한다.\n4. 이로 인해 git clone한 파일의 업데이트 히스토리를 파악할 수 없게된다.\n5. 빌드시 생성일자로 최근 수정일자가 업데이트 날짜로 들어간다.\n\nshallow clone이 되지 않게하려면 `git clone`시 `fetch-depth`를 0으로 지정해줘야한다.\n\n하지만 cloudflare pages 설정화면에서 아무리 찾아봐도 git clone시 옵션을 전달할 수 있는 방법은 없었다.\n결국 github action으로 github pages에 배포하여 문제를 해결했다.\n"},{"fields":{"slug":"/posts/library/react-query/fail-request/","title":"react-query 동작 안하는 이슈 해결"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: react-query 동작 안하는 이슈 해결\ndate: 2024-09-28\nupdated: 2024-09-28\ntags:\n  - \"react-query\"\n---\n\n## 현상\n최근 몇몇 소수의 유저들에게서 빈 화면이 노출되는 현상이 있었다.\n한 서비스에서만 발생한게 아니라, 분리되어있는 서로 다른 react, Next.js 애플리케이션에서 발생해서 의아해했다.\n해당 유저들의 공통점은 아무 요청을 하지 못해 마치 인터넷 연결이 끊겨있는 것처럼 보였다.\n모니터링툴에서도 도움이 될만한 에러 로깅이 남지도 않아서 원인을 알 수 없었다.\n\n## 과정\n- 아예 요청 자체를 못 보내는 건가?\n  - 디버깅용으로 일반 fetch코드를 심어 놓았다. 잘 요청되는 게 확인됐다.\n- 리액트 쿼리 4버전을 사용하고 있었다.\n  - 작년에 리액트 쿼리 3버전에서 4버전으로 넘어오면서 이런 비슷한 이슈가 있어서 팀원분이 디깅을 했었던 적이 있었다. 그때 작성됐던 슬랙 쓰레드가 기억나서 확인해 보니 [스택오버플로우 글](https://stackoverflow.com/questions/75538301/reactquery-queryfn-passed-to-usequery-is-never-run-happens-only-on-chrome)이 하나 있었다.\n- 리액트 쿼리는 내부적으로 `window.navigator.onLine` [플래그 값을 사용하고 있는데](https://github.com/TanStack/query/blob/b82f05e3028718f03eb132a4dd92dc3d7623f7b5/packages/query-core/src/onlineManager.ts#L80-L87), 이 값이 인터넷에 연결되어있음에도 불구하고 `false`로 되어있는 경우가 있다는 이슈가 있었다. ([참고](https://issues.chromium.org/issues/41293401))\n- 리액트 쿼리에서는 [networkMode](https://tanstack.com/query/v4/docs/framework/react/guides/network-mode#network-mode-online)라는 옵션을 설정 수 있는데, 위에서 문제가 됐던 `onLine` 플래그 값을 무시하고 항상 요청하도록 할 수 있도록 `always`로 설정하여 문제를 해결했다...!\n\n## 교훈\n- 프로그램이 동작하는 곳이 항상 제대로 동작할 거라는 100% 믿음을 가지는것보다 가끔 의심을 가지는 게 좋다.\n- 동료가 남기는 자료들을 잘 챙겨 보고, 잘 저장해놓자. (거의 1년이된 쓰레드에서 실마리를 발견했다)\n"},{"fields":{"slug":"/posts/library/shaka-player/shaka-player tip/","title":"에러 모니터링"},"frontmatter":{"draft":false},"rawBody":"---\ncreated: 2023-03-23T16:21:22+09:00\nupdated: 2024-05-05T17:21:15+09:00\n---\n\n# 에러 모니터링\nshaka player에서 에러가 발생하면 다음과 같은 형태의 에러 로그를 남겨준다.\n```typescript\n{ category: number, code: number, data: unknown, severity: number }\n```\n\n각 프로퍼티별 숫자 코드가 나타내는 의미는 [공식 문서](https://shaka-player-demo.appspot.com/docs/api/shaka.util.Error.html#.Code)에서 확인할 수 있다.\n\n# 동영상 실행 관련 지식\n- 동영상을 전달하는 방식\n\t- [http chunk 스펙 활용 방식](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding)\n\t\t- 파일을 안자르고 http 스펙을 사용해서 자른것 처럼 보내는 방식\n\t- 실제로 파일을 잘라 전달하는 방식\n\t\t- ![[m3u8.png]]\n\t\t- 실제로 파일을 잘라서 전송하는 방식\n\t\t\t- m3u8: 영상 재생을 위한 메타 정보\n\t\t\t- ts: 잘개 쪼개진 실제 스트리밍 영상 데이터\n\n# shaka-player interface\n- isSeeking()\n\t- Class: [shaka.ui.Controls](https://shaka-player-demo.appspot.com/docs/api/shaka.ui.Controls.html) \n\t- 유저가 마우스나 손가락을 통해 컨트롤 바를 탐색할 때 true가 반환된다.\n- trackchanged 이벤트\n\t- 커스텀 이벤트로 플레이어에 전달되고 있던 트랙이 변경되면 이벤트가 트리거된다. 예를 들면 영상 자체가 변경되는 경우\n- getNetworkingEngine()\n\t- registerRequestFilter, registerRequestFilter\n\t\t- 각각 플레이어가 요청, 응답하는 네트워킹 활동에 대해서 파이프 함수를 등록할 수 있다.\n\n# 에러 대응\n\n## H.264 코덱 영상 재생시 4032, 3016 에러 발생\n### 에러메시지\n`Failed to read the 'buffered' property from 'SourceBuffer'`\n\n### 원인\nH.264 High 10 프로파일 코덱을 사용함.\n웹 브라우저는 H.264 베이스라인, 메인, 하이 프로파일은 지원하지만 High 10 프로파일은 지원하지 않음.\n\n### 해결방법\n영상을 인코딩할 때 원본영상이 10bit라도 강제로 8bit로 인코딩 되도록 함.\n\n### 해결과정\n영상 관련지식 구글링하다가 크롬이 제공하는 개발자도구 중\u001c chrome://media-internals 라는걸 알게됨 ([링크](https://www.chromium.org/audio-video/media-internals/))\n해당 URL에서는 현재 브라우저에서 재생되고 있는 video/audio 들에 대한 정보와 로그들을 볼 수 있음. 로그에서 에러 관련 메시지를 확인할 수 있었음. 그러나 영상 관련해서 깊은 지식을 가지고 있진 않아 원인 파악 불가\n하여 사용중인 claude3 ai 한테 넷플릭스의 영상 재생 전문가라는 역할을 부여한 후, 정보와 로그를 보여줌\n\n그러자 정확한 원인과 해결방법 또한 알려줌. 해당 내용을 유관부서 담당자에게 전달하였고 가지고 있던 지식과 이 정보를 합쳐 문제 해결\n\n0에서 1로 만드는 창의력이 필요한 작업이 아니라 이미 정답이 정해져 있는데, 그게 복잡하고 찾기 어려운 문제의 경우 대화형 AI를 활용하면 엄청 좋다는 걸 체감했다.\n\n\n# 관련 지식\n- [EME (Encrypted Media Extension)란?](https://github.com/LeeJaeBin/About-EME)\n- [동영상 플랫폼 이해하기 (1) - HLS](https://americanopeople.tistory.com/336)\n- [HTTP Live Streaming](https://d2.naver.com/helloworld/7122)"},{"fields":{"slug":"/posts/study/codesoom-git/git-deep-dive-02/","title":"git 딥다이브 - git merge, rebase"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: git 딥다이브 - git merge, rebase\ndate: 2022-10-02\nupdated: 2022-10-02\ntags:\n  - git\n---\n\n---\n\n\n> 해당 내용은  코드숨 강의 `소프트웨어 개발의 지혜 <Git 편>` 을 보고 정리한 내용입니다.\n\n# git commit —amend\n\n보통 커밋 메시지를 수정해야할 때 해당 명령어를 사용하여 해결한다. 사실 이 명령어는 커밋 메시지를 수정하는게 아니라 아예 새로운 커밋을 만들고 마지막 커밋을 새로운 커밋으로 바꿔치는 명령어이다.\n\n- parent 노드: 마지막 커밋이 바라 보던 커밋\n- A: 기존 커밋 노드\n- B: amend한 커밋\n\n- parent (parent를 바라보는 노드는 A,B 둘다 임)\n    - A\n    - B\n        - git/head\n\n# merge\n\n- 작동 순서\n    1. `git rebase b`\n    2. 두 브랜치간의 공통 부모 노드를 찾음\n    3. 부모노드부터 b브랜치의 헤드까지 변경사항들을 찾음\n        1. 말단 파일이 나올때까지 재귀적을 탐색하는데 효율을 위해 해쉬값이 변경되지 않은 디렉토리는 더 이상 탐색을 진행하지 않는다.\n    4. 현재 브랜치에 변경사항들 적용\n    5. merge 커밋은 부모 노드가 두개임. (대상이 되는 브랜치들)\n        1. 참고로 부모커밋은 최대 2개까지만 가능하며 0개인 경우도 있다.(최초 커밋)\n\n## conflict\n\n머지가 정상적으로 이루어지지 않은 경우, 자동적으로 병합되지 않고 충돌이 발생한다. 이때 어떤 코드를 지우고 어떤 코드를 남길것인지는 수동으로 직접 해결해줘야한다.\n\n주로 병합하려는 커밋들의 변경사항중 동일한 위치의 코드가 존재하면 발생한다.장하고 있기 때문에 현재 내가 위치한 브랜치가 어딘지 알 수 있다.\n\n# cherry-pick\n\n-   다른 커밋의 변경사항을 현재 HEAD가 가리키고 있는 브랜치에 적용하는 명령어\n-   체리픽으로 커밋을 가져온 경우 커밋해쉬가 같지 않다. 다만 내용은 같아서 tree는 동일함\n-   fast-forward\n    -   `git cherry-pick branch-name -ff`\n    -   일반 체리픽을 하면 커밋이 새로 생성되지만 fast-forward 옵션을 붙이면 기존 커밋을 가져와 기존 커밋에 연결시킨다.\n-   `-n`\n    -   `git cherr-pick branch-name -n`\n    -   체리픽을 하지만, 커밋하기 직전까지만 수행한다. git status를 실행시 stage에 올라가있지만 커밋이 안되어있는 상태가 된다.\n\n![[rebase-01.png]]\n\n-   지정한 커밋의 변경사항만 가져오는 예시\n\n-   한번에 여러개 체리픽하기\n\n    -   `git cherry-pick a1 a2 a3`\n    -   연속적으로 있는 경우 `git cherry-pick a1..a3`\n\n# rebase\n\n-   작동 순서\n\n    1.  `git rebase b`\n    2.  두 브랜치간의 공통 부모 노드를 찾음\n    3.  부모노드부터 b브랜치의 헤드까지 변경사항들을 찾음\n    4.  현재 브랜치에 변경사항들 적용\n-   merge와 뭐가 다른가?\n\n    -   merge 커밋은 부모 노드가 두개임. (대상이 되는 브랜치들)\n    -   rebase는 부모노드가 1개임\n-   rebase시, 현재 브랜치의 헤드가 대상이 되는 브랜치의 부모인 경우\n\n\n![[rebase-02.png]]\n\n    -   fast-forward 상태이기 때문에 변경사항이 없다. 다만 `-ff` 옵션을 사용하면 fast-foward가 아닌 머지가 가능하다."},{"fields":{"slug":"/posts/study/codesoom-git/git-deep-dive-01/","title":"git 딥다이브 - git branch, tag, HEAD"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: git 딥다이브 - git branch, tag, HEAD\ndate: 2022-09-24\nupdated: 2022-09-24\ntags:\n  - git\n---\n\n\n> 해당 내용은  코드숨 강의 `소프트웨어 개발의 지혜 <Git 편>` 을 보고 정리한 내용입니다.\n\n\n## Database\n깃은 내부적으로 key-value형태인 db를 가지고 있다. 우리가 흔히 깃 로그에서보는 hash을 key로써 사용한다. 흔히 아는 DBMS에서는 CRUD가 가능하지만 git의 DB는 Create, Read만 가능하다. 즉 우리가 날려먹은 커밋은 항상 어딘가에 저장되어있다는 뜻이다.\n\n### hash\n해쉬함수는 동일한 입력에 대해서는 동일한 길이의 해쉬값을 반환하는 함수이다. 입력이 조금만 달라도 반환되는 해쉬값은 크게 달라질 수 있다.\n\n깃은 루트 디렉토리부터 재귀적으로 탐색하며 해쉬값을 계산한다. 각 파일과 디렉토리는 해쉬값을 가지게 되고, 깃은 이를 트리구조로 다룬다. 동일한 내용을 가지고 있는 파일들은 같은 해쉬값을 가지기 때문에 중복되지 않게 1개만 저장한다. ([[Blob]] 형태로)\n\n\n## commit\n `git add .` ,  `git commit -m \"first commit\"`  명령어로 남기는 commit은 다음과 같은 구조로 이루어져있다.\n-   프로젝트의 스냅샷에 대한 최상위 트리의 해쉬값\n-   부모 commit의 해쉬값(최초 commit의 경우 `null`)\n-   메타데이터(작성자, 이메일, 날짜와 시간, 메시지 등등)\n\t- 이런 내용을 저장하고 있기 때문에 깃허브 같은곳에서 프로필을 보여줄수 있는것이다.\n\n## git reset\n `git reset --hard bb178` 명령어를 실행시켰을때 코드가 변경되는 과정\n 1. 루트 commit의 내용을 조회한다\n 2. commit의 타입이 tree이라면 재귀적으로 다시 조회한다.\n 3. commit의 타입이 blob이라면 탐색을 멈춘다.\n\t 1. 저장되어있는 blob과 해쉬값로 실제 데이터를 복구할 수 있다.\n\n## git cat-file\n그럼 조회는 어떻게 할 수 있을까?\n`git cat-file`은 내부에 저장되어있는 데이터를 직접 조회하여 출력해준다. 실무에서는 사용할 일이 없는 저수준 명령어다. 우리가 흔히 사용하는 `git commit`, `git push` 등은 고수준 명령어다.\n\n아래는 `git cat-file`을 통해 내부를 살펴보는 과정이다.  참고로 `-p` 옵션은 터미널에 출력하기 위해 사용하는 옵션이다.\n\n```\n// 가장 최근 commit해쉬값은 97a6d1d0adc60468907eb110edfa261235cbed65 이다\n>> git cat-file -p 97a6d1d0adc60468907eb110edfa261235cbed65\n\ntree e6322c144fd063164c7703a08e6b66bc67c3861a // 자식commit의 타입과 해쉬값\nparent 2d7d2e753e11456416f094096e8133aa8491d2ca // 부토 commit의 해쉬값\nauthor padawanr0k <padawanr0k@gmail.com> 1662276911 +0900 // 메타정보\ncommitter padawanr0k <padawanr0k@gmail.com> 1662276911 +0900 // 메타정보\n\nedit: update about page // commit 메시지\n```\n\n```\n>> git cat-file -p e6322c144fd063164c7703a08e6b66bc67c3861a\n\n// 파일인 경우 blob 타입이다.\n040000 tree ba76e2fa97e49cd30dcc9cf2144535bfdfe86e4b\t.circleci\n100644 blob 555497f4ae4d817ea6dbc9fc8b7f1996984ff670\t.editorconfig\n100644 blob f7bc505cfbec1f078a5c8ebd2e478fa781353c4e\t.eslintignore\n100644 blob aac0d6af88901909a654863da54dde72b4396696\t.eslintrc.js\n040000 tree 4570719c6c57b3389e45456a4861a2b23300912a\t.github\n100644 blob 8a5c6433652426376c1e582f146c2b4ccdb2e989\t.gitignore\n100644 blob 8351c19397f4fcd5238d10034fa7fa384f14d580\t.nvmrc\n100644 blob ed1050f5c2796d9ddadad188bc3a6928fde850d6\t.prettierrc\n100644 blob 78a89585e2f058c91ff035437513739941f1bf62\tLICENSE\n100644 blob f89b2bb7e811eb7b71eadccad08ef64b8258a92f\tREADME.md\n100644 blob 17baafcdf24932a99c232e5989d17e7433bbbc5a\tgatsby-config.js\n100644 blob 703ed68983760b99ab225a206711950516940b45\tgatsby-node.js\n100644 blob 563e0ec37fe147f9de692f2e54a9f238e25b0bd1\tpackage-lock.json\n100644 blob 52c32892f9f9ca34f4f5c84198d1fe9808c80f7d\tpackage.json\n040000 tree c5840f799e2f4fe56eda6ee0d971d331c66dceb7\tsrc\n100644 blob 4b508f20101e30970715d0c13e13efe7db688cc9\ttsconfig.json\n100644 blob 4e09728775d202ffbab842557d6a04e851bf46d8\tyarn.lock\n```\n\n```\n>> git cat-file -p 555497f4ae4d817ea6dbc9fc8b7f1996984ff670 // .editorconfig 파일의 해쉬값\n\n\n# Editor configuration, see http://editorconfig.org\nroot = true\n\n[*]\nindent_style = space\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\nindent_size = 2\n\n[*.md]\ntrim_trailing_whitespace = false\n```\n\n\n## commit 간의 상관관계\ncommit의 해쉬값은 프로젝트 내부의 해쉬값들을 하나의 해쉬값으로 취합한 것이다. 그러므로 파일이 하나라도 변경되면 새로운 commit 해쉬값이 생기는 것이다.\n![[git-hash-tree.png]]\n### 효율화\n파일하나의 변경이 모든 해쉬값을 변경시킨다면 비효율적일 것이다. git db는 트리구조로 데이터들을 관리하기 때문에 변경된 부분의 부모노드를 타고 올라가며 재귀적으로 순회하며 변경한다. 그러므로 불필요하게 자식노드나 형제노드의 해쉬값은 변경되지 않는다. 이게 깃이 빠른 이유이다.\n\n변경된 부분을 직접 출력해보고 싶다면 `git diff A커밋해쉬 B커밋해쉬` 명령어를 사용해보자\n\n\n## branch, tag, HEAD\nbranch, tag, HEAD들은 하나의 레퍼런스이다. 특정위치를 기억하기 위해 해쉬값을 기억하고 있는 파일이\n\n### branch\n- 하나의 커밋에 고정되지 않고 자식 노드가 생기면 옮겨간다.\n- `.git/refs/heads` 에 위치한다.\n\t-   태그와 비슷하게 브랜치명을 가진 파일이 존재하고, 해쉬값을 가지고 있다.\n-   가끔씩 브랜치명에 `/`를 넣는 경우가 있다. 이 경우 내부적으로 파일이 생성될 때 하나의 파일이 아닌 디렉토리와 함께 생성된다.\n\n### tag\n하나의 커밋에 고정되어 움직이지 않는다.\n-   `.git/refs/tags` 에 위치한다.\n-   태그명으로된 파일은 해당 태그가 위치한 커밋의 해쉬를 가지고 있는데 이를 수정하면 태그의 위치도 변경되게된다. 마찬가지로 해달 파일을 삭제하면 태그가 삭제된다.\n\n### HEAD\n-   내가 현재 어떤 브랜치를 보고 있는지를 나타낸다.\n-   `.git/HEAD` 에 위치한다.\n\t-   `ref: refs/heads/{{branch name}}` 처럼 현재 브랜치의 위치를 나타내는 값을 가지고 있다.\n\n### git reset\n`git reset` 명령어는 코드를 타임머신처럼 이동할 수 있게해준다. 내부적으로는 현재 브랜치가 바라보고 있는 커밋(해쉬값)을 바꾸기 때문에 가능한 것이다.\n\n### logs\n-   `git/logs/HEAD`\n    -   지금까지 만든 커밋 해쉬값들을 저장하고 있다.\n    -   `git reset`으로 실수로 커밋을 날렸을 때, 실제로는 커밋해쉬들이 여기에 저장되기 때문에 커밋이 날라간게 아니다\n-   `git reflog`\n    -   `git/logs/HEAD`에 저장된 커밋 해쉬들을 볼 수 있는 명령어다.\n\n## 생각해보기\n\n### **브랜치와 태그는 무엇인가요? 무엇을 저장하고 있나요?**\n-   브랜치와 태그는 둘다 파일로 다루어진다.\n-   브랜치명에 `/`를 추가하면 파일로 저장될때 폴더링이 되어 저장된다.\n-   브랜치는 브랜치의 이름과 가장 최근 커밋을 저장하고 있다. 특정 브랜치에서 커밋을 추가하면 최근 커밋의 자식 노드가 생기고 자식노드는 이전 커밋을 부모로 가진다.\n-   태그는 특정 커밋을 저장한다. 태그는 중복될 수 없다.\n-   태그 또한 파일로 관리되는데, 이를 직접 편집기로 열어 수정하면 태그가 달리는 커밋을 변경할 수도 있다.\n\n### **브랜치와 태그의 차이점은 무엇인가요?**\n-   브랜치는 부모 브랜치로부터 분기가 된 후, 말단 노드를 계속 업데이트해 나간다. 브랜치 정보를 저장하고 있는 파일의 해쉬값은 커밋이 추가될 때 마다 변경된다.\n-   태그는 변하지 않는다. 어떤 커밋에 태그를 달게 되면 태그파일이 생성되고, 태그파일에 해당 커밋 해쉬값을 저장한다.\n-   브랜치는 마치 학교의 교장선생님, 교감선생님 직무와 비슷하다. 교장선생님들은 1대, 2대 이런식으로 몇대인지 앞에 태그가 붙게된다. 모두 같은 직무를 수행해나가고 있는건 맞지만, 구별하기 위해 태그를 붙인다.\n\n### **현재 가리키고 있는 브랜치가 무엇인지 어떻게 알 수 있나요?**\n-   현재 내가 위치한 곳의 정보는 git의 `HEAD`를 통해 알 수 있다.\n-   `HEAD` 는 `git/HEAD` 파일에 저장된다. 해당 파일을 보면 `ref: refs/heads/{{branch name}}` 이런식으로 내가 현재 위치한 브랜치의 파일 위치를 저장하고 있기 때문에 현재 내가 위치한 브랜치가 어딘지 알 수 있다."},{"fields":{"slug":"/posts/study/codesoom-git/git-deep-dive-03/","title":"git 딥다이브 - history"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: git 딥다이브 - history\ndate: 2022-10-02\nupdated: 2022-10-02\ntags:\n  - git\n---\n\n---\n\n\n> 해당 내용은  코드숨 강의 `소프트웨어 개발의 지혜 <Git 편>` 을 보고 정리한 내용입니다.\n\n개발을 하다보면 여러 커밋중 일부를 아예 없에거나, 되돌리되 기록을 남기거나 하고 싶은 경우가 있다. 이런 경우 revert 나 rebase 를 사용하여 문제를 해결할 수 있다.\n\n# revert\n\n![[revert-01.png]]\n\n![[revert-02.png]]\n\n\n-   특정 커밋이 가지고 있는 변경사항의 이전 내용을 복구한다. 새롭게 커밋이 추가되는데 이때 기본적으로 커밋의 메시지는 `Revert {{이전 커밋메시지}}` 이다.\n-   특정 커밋이 아닌 범위를 지정할 수도 있다.\n\n```bash\ngit revert HEAD~3 # head 포함 최근 커밋 3개\n\ngit revert -n master~5..master~2\n```\n\n# rebase\n\n-   커밋의 내용들을 수정한다. `-i` 옵션은 interactive를 뜻한다. 터미널에서 해당 명령어를 실행시켜보면 유저의 입력과 상호작용하며 깃 히스토리를 수정할 수 있다.\n    -   편집기에는 유저가 입력한 매개변수에 따라 커밋 리스트를 보여주고, 어떤 옵션이 있는지 주석으로 적혀있다.\n\n        ```bash\n        pick 9a54fd4 commit의 설명 추가\n        pick 0d4a808 pull의 설명을 추가\n\n        # Rebase 326fc9f..0d4a808 onto d286baa\n        #\n        # Commands:\n        #  p, pick = 커밋 유지\n        #  r, reword = 커밋 유지, 커밋 메시지 수정\n        #  e, edit = 커밋 유지, 해당 커밋이 amend될 때 자동 병합을 멈춤\n        #  s, squash = 커밋 유지, 다만 이전 커밋과 squash\n        #  f, fixup =  like \"squash\", but discard this commit's log message\n        #  x, exec = run command (the rest of the line) using shell\n        #\n        ```\n\n\n\n커밋기록을 통해 코드를 이전 상태로 되돌리는 목적으로 사용되는것은 매한가지이다. 다만 각각의 명령어를 실행했을때 커밋이 바뀌는 메커니즘이 다르기 때문에 지금 처한 상황이 어떤지 파악하고, 어떻게 커밋 기록을 남겨야할지 고민한 후 적절한 명령어를 사용하면 된다.\n\n## 영상 자료\n\n솔직히 rebase는 텍스트로 보면 이해하기 힘들다. 대신 영상자료를 추천함\n\n-   **[git 히스토리를 마음대로 편집하기 - interactive rebase](https://www.youtube.com/watch?v=ZMoB1SZ4Ceg&ab_channel=%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9)**\n-   **[Git 무료 강좌 2-3. git merge, git rebase(#10, #11)](https://www.youtube.com/watch?v=Kh-m5mLedfs&ab_channel=ZeroChoTV)**"},{"fields":{"slug":"/placeholder/","title":"This Is a Placeholder File for Mdx"},"frontmatter":{"draft":true},"rawBody":"---\ntitle: This Is a Placeholder File for Mdx\ndraft: true\ntags:\n  - gatsby-theme-primer-wiki-placeholder\n---\n"}]}}}